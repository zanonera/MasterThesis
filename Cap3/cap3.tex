%\section{Theoretical Introduction}
\label{sec:cap3}

This chapter presents the theoretical background necessary to understand the techniques and concepts explored in this dissertation. It introduces the reliability challenges of \gls{cots} \gls{sram} \glspl{fpga}, examines fault-tolerance techniques such as \gls{nmr} and \gls{dpr}, discusses memory scrubbing mechanisms, and outlines the principles of \gls{fi} for resilience evaluation.

\section{\glsentrytext{fpga}}
This section introduces the \gls{fpga} architecture, focusing on the role of configurable logic blocks, routing resources, and configuration memory.

A \gls{fpga} is a reconfigurable logic device or a programmable \gls{ic} widely used for the implementation of digital systems.

\glspl{fpga} can be reconfigured by the user, even after deployment \cite{Mazzeo2019}, enabling rapid prototyping, hardware acceleration, and long-term design flexibility.

\glspl{fpga} are successful platforms because they combine the flexibility of software with the speed of hardware, providing adaptable computing cores and high-throughput processing of data streams. They are particularly attractive compared to \glspl{asic} due to their shorter development time and costs, and their ability to be reconfigured \cite{8524728}.

The main advantage of \glspl{fpga} over software-based implementations lies in their inherently parallel architecture, which allows computations to be executed concurrently. For applications that can exploit this parallelism, \glspl{fpga} offer significant performance advantages \cite{Wilson2020_VideoPipelines}.

\subsection{Core Structure and Components}

An \gls{fpga} is essentially a complex heterogeneous device implemented on a single chip. Its basic structure consists of an array or matrix of configurable interconnected elements, as illustrated in Figure~\ref{fpga-arch}.

\subsubsection{Configurable Logic Blocks}
These are the elementary logic blocks used to implement the desired logic functions. The \glspl{clb} (sometimes called Logic Cells or Logic Array Blocks, depending on the \gls{fpga}'s manufacturer) perform simple combinational and sequential logic.

In the Zynq 7000 \gls{soc}, \gls{clb} contains a pair of slices, and each of the slices contains four 6-inputs \glspl{lut} and eight storage elements \cite{AMD_UG585}.

These two slices are independent and organized in columns, as illustrated in Figure~\ref{fpga-arch-clb-slice-amd}, and have the following features:

\begin{itemize}
    \item Can be configured as a single 6-input \gls{lut} or two 5-input \glspl{lut};
    \item storage elements (memory capability);
    \item Register (\gls{ff}) and shift register available.
\end{itemize}

A \gls{lut} with $m$ inputs can implement any Boolean function defined over those $m$ variables. For example, a 6-input \gls{lut} can realize any six-variable Boolean function, two arbitrary five-variable functions if they share common inputs, or two independent Boolean functions of up to three and two inputs, respectively \cite{Battezzati2010, Mazzeo2019, AMD_UG585}.

The \glspl{lut} can also be configured for other structures, including the so-called distributed memory, where each slice can be configured as a 64-bit \gls{ram}, a 32-bit shift register (SRL32), or two 16-bit shift registers (SRL16).

\begin{figure}[ht]
\centering
\includegraphics[width=0.75\textwidth]{Cap3/Arrangement-of-Slices-within-the-CLB.png}
\caption{Structure of a \acrshort{clb} in an AMD's 7-series \acrshort{fpga}. Reproduced from \textcite{AMD_UG474}.}\label{fpga-arch-clb-slice-amd}
\end{figure}

\subsubsection{Routing and Interconnect Resources}
These resources, including \glspl{sb}, \glspl{cb}, and \glspl{pip}, form a network that electrically interconnects the \glspl{clb}, I/O blocks, and embedded resources to implement complex systems.

\subsubsection{Input/Output Blocks (IOBs)}
These blocks are positioned around the logic core to interface the internal logic with the external environment, handling input and output data.

\subsubsection{Specialized Heterogeneous Resources}
Modern \glspl{fpga} also includes various specialized resources beyond the basic structure, such as:
\begin{itemize}
    \item \textbf{Embedded Memories}, such as \glspl{bram}.
    \item \textbf{Arithmetic Resources}, such as \gls{dsp} units.
    \item \textbf{Processing Resources}, which can be hard cores (e.g. ARM Cortex processors on Xilinx Zynq-7000 \gls{apsoc}) or soft processors implemented using programmable logic.
    \item \textbf{Clock-management resources}.
\end{itemize}

As illustrated in Figure~\ref{fpga-arch}, the \gls{fpga} architecture consists of configurable logic blocks, routing resources, and \gls{io} blocks.

\begin{figure}[ht]
\centering
\includegraphics[width=0.75\textwidth]{Cap3/fpga-structure.png}
\caption{General structure of an \acrshort{fpga}. Adapted from \textcite{Marioli2010}.}\label{fpga-arch}
\end{figure}

As illustrated  in Figure~\ref{fpga-column-asmbl}, the \gls{fpga} architecture has other specialized hardware, AMD's 7-series is totally based on the columnar approach provided by the \gls{asmbl} architecture. The different domains represent the diverse platforms with varying feature mixes optimized for different application domains \cite{AMD_UG474}.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{Cap3/X30271-ASMBL-Architecture.png}
\caption{Specialized hardware resources present in AMD 7-series \acrshort{fpga} devices. Reproduced from \textcite{AMD_UG474}.}\label{fpga-column-asmbl}
\end{figure}

\subsection{Configuration and Reprogrammability}

\glspl{fpga} are programmable devices whose behavior is defined by the \textit{bitstream} loaded to its \gls{cram}. This bitstream contains all the information needed to configure the blocks in the \gls{fpga} architecture, mapping the user-defined \gls{hdl} design to the available logic and routing elements.

The characteristics of the device are determined by the technology used in \gls{cram}, as follows:

\begin{itemize}
    \item \textbf{\gls{sram}-based \glspl{fpga}:} These are the most widely used commercial \glspl{fpga} due to their high reconfiguration flexibility, the ability to integrate complex systems and their competitive costs. They use \gls{sram} cells, known as \gls{cram}, to store the configuration of all internal \glspl{lut} and functions of the device. This technology allows \glspl{fpga} to be reprogrammed in an virtually infinite number of cycles and allows \textit{\gls{dpr}}, which means that parts of the configuration can be changed during runtime. A significant drawback is that \gls{sram} cells are volatile and highly susceptible to radiation-induced faults such as \glspl{seu} \cite{Adria2023}.

        \item \textbf{Flash-based \glspl{fpga}:} These are reconfigurable and non-volatile, meaning the configuration memory is immune to \glspl{seu}. However, they may have lower capacity and fewer reprogramming cycles compared to \gls{sram} devices \cite{Wubs2023}.

    \item \textbf{Antifuse \glspl{fpga}:} These are \gls{otp} devices whose configuration cannot be changed once set. Their configuration memory is immune to radiation effects, making them suitable for harsh environments, but they offer lower logic capacity \cite{Garcia2020,bates2016,Wang2003_RadiationEffectsFPGAs}.
\end{itemize}

\subsubsection{Bitstream}

The bitstream represents the device's configuration for a specific application and is downloaded to the \gls{fpga}'s \gls{cram} at startup. Its exact structure and semantics are proprietary and have become increasingly complex over the years.

Several initiatives have attempted to document the structure of the 7‑series bitstream via reverse engineering; a representative example can be seen in the \textcite{f4pga_prjxray} project.

Figure~\ref{fpga-simple-bitstream} illustrates, very simplistically, the structure of the bitstream, where the header and footer appear at the beginning and end of the structure, the sync word and then the \gls{far} that points to one frame \cite{Xilinx_UG470_7Series_Config}.

Before any configuration packet is processed by the \gls{fpga}, the configuration logic must first detect a specific synchronization pattern. For Xilinx devices, this synchronization word has the hexadecimal value \texttt{0xAA995566}. It allows the configuration logic to align data at a 32-bit word boundary, ensuring correct interpretation of subsequent configuration packets. In parallel configuration modes, successful detection of the bus width is required before recognizing the synchronization word \cite{f4pga_prjxray}.

\begin{figure}[ht]
\centering
\includegraphics[width=0.5\textwidth]{Cap3/simple-bitstream.png}
\caption{Simplified representation of the \acrshort{fpga} bitstream structure, illustrating the organization of configuration frames and data fields.}\label{fpga-simple-bitstream}
\end{figure}

A frame is the smallest unit of configuration data that can be read or written in an \gls{fpga}, identified by a unique 32-bit address divided into five fields: block type, top/bottom position, row address, column address, and minor address \cite{AMD_UG953_IBUF}. Frame addresses are discontinuous due to block cross-distribution, with different blocks corresponding to different frames. These non-contiguous addresses are called physical frame addresses (PFAs), while sequentially arranged PFAs are referred to as linear frame addresses (LFAs) \cite{Xie2023_HybridGrainedScrubbing}. Since bitstream-to-PFA mapping is proprietary, repairing upsets by reconfiguring frames is challenging. Several studies have explored this mapping to infer bitstream structure and address allocation, including \textcite{LeRoux2019,Aranda2019,Xie2023_HybridGrainedScrubbing}.

A 7-series \gls{fpga} frame consists of 101 words of 32 bits each, where 100 words store configuration data and 1 word contains \gls{ecc} for error correction within the frame.

\section{Sources of Faults in \glsentrytext{fpga}}

Integrated circuits operating in radiation environments are susceptible to transient and permanent faults caused by the interaction of ionizing particles with silicon. Ionizing radiation can generate electrical disturbances by depositing a charge that alters transistor states. This deposition occurs either directly, when charged particles interact with the material, or indirectly, when neutral particles such as neutrons produce secondary charged particles (e.g., alpha particles, ions, or protons). The severity of the effect depends on the amount and location of the charge deposited within the semiconductor \cite{KastensmidtRech2016}.

\glspl{see} encompasses all radiation-induced phenomena resulting from the interaction of energetic particles with electronic components. These effects are generally classified as hard or soft errors. Hard errors, such as Single Event Burnout (SEB), Single Event Gate Rupture (SEGR), and latch-up (SEL), are permanent and often destructive, while soft errors are recoverable through reset, power cycling, or data rewriting \cite{GomezToro2014}. Among soft errors, Single Event Upsets (SEUs) cause bit flips in memory elements, Multiple-Bit Upsets (MBUs) (also called Multiple-Cell Upsets (MCUs)) affect multiple storage cells, and Single Event Transients (SETs) induce temporary voltage pulses in analog or combinational logic circuits. In complex integrated systems, Single Event Functional Interrupts (SEFIs) can disrupt control logic or clocks, leading to temporary loss of functionality that typically requires reconfiguration or reset for recovery \cite{Nicolaidis2011,Daniello2025_SEU_ShiftRegister16nm}.

Figure~\ref{fig:see_hard_soft} illustrates the classification of the \gls{see} phenomena and their respective subtypes.

%%Types of Errors
\usetikzlibrary{shapes.geometric, arrows}

\tikzstyle{block} = [rectangle, rounded corners, minimum width=4cm, minimum height=1cm, text centered, draw=black, fill=blue!20]
\tikzstyle{subblock} = [rectangle, rounded corners, minimum width=3.5cm, minimum height=0.8cm, text centered, draw=black, fill=green!20]
\tikzstyle{arrow} = [thick,->,>=stealth]

\begin{figure}[ht]
\centering
\begin{adjustbox}{max width=\textwidth}
\begin{tikzpicture}[node distance=1.5cm]

% Top-level SEE
\node (see) [block] {Single Event Effects (SEE)};

% Soft SEE
\node (soft) [subblock, below left of=see, xshift=-5cm, yshift=-1cm] {Soft SEE};
\node (seu) [subblock, below of=soft, yshift=-0.5cm] {Single Event Upset (SEU)};
\node (mbu) [subblock, below of=seu, yshift=-0.5cm] {Multi-Bit/Cell Upset (MBU/MCU)};
\node (set) [subblock, below of=mbu, yshift=-0.5cm] {Single Event Transient (SET)};
\node (sefi_soft) [subblock, below of=set, yshift=-0.5cm] {Single Event Functional Interrupt (SEFI)};

% Hard SEE
\node (hard) [subblock, below right of=see, xshift=5cm, yshift=-1cm] {Hard SEE};
\node (sel) [subblock, below of=hard, yshift=-0.5cm] {Single Event Latchup (SEL)};
\node (sehe) [subblock, below of=sel, yshift=-0.5cm] {Single Event Hard Error (SEHE)};
\node (segr) [subblock, below of=sehe, yshift=-0.5cm] {Single Event Gate Rupture (SEGR)};
\node (seb) [subblock, below of=segr, yshift=-0.5cm] {Single Event Burnout (SEB)};

% Arrows from SEE to Soft and Hard
\draw [arrow] (see.south west) -- (soft.north);
\draw [arrow] (see.south east) -- (hard.north);

% Arrows within Soft SEE
\draw [arrow] (soft.south) -- (seu.north);
\draw [arrow] (seu.south) -- (mbu.north);
\draw [arrow] (mbu.south) -- (set.north);
\draw [arrow] (set.south) -- (sefi_soft.north);

% Arrows within Hard SEE
\draw [arrow] (hard.south) -- (sel.north);
\draw [arrow] (sel.south) -- (sehe.north);
\draw [arrow] (sehe.south) -- (segr.north);
\draw [arrow] (segr.south) -- (seb.north);

\end{tikzpicture}
\end{adjustbox}
\caption{Hierarchical classification of \acrlong{see} phenomena affecting electronic devices.}
\label{fig:see_hard_soft}
\end{figure}


This research focuses exclusively on soft errors, while hard errors are beyond the scope of this study and will not be discussed further.

\subsection{Single Event Upsets (SEUs) and Failure Modes}

Most modern high-density \glspl{fpga} rely on \gls{sram} cells to store their configuration bitstream. 

This \gls{cram} defines the functionality of logic blocks (\glspl{lut} and \glspl{ff}) and all internal interconnections. 

Unfortunately, this reliance on volatile \gls{sram} renders \glspl{fpga} highly susceptible to soft errors induced by high-energy ionizing radiation, a phenomenon particularly severe in environments such as space.

As the size of the technology features decreases, \glspl{seu} and \glspl{set} become the dominant radiation-induced effects in modern microelectronic circuits. In addition, \glspl{mbu}—events in which multiple configuration or memory bits are simultaneously affected—are increasingly significant due to the higher integration density and reduced node capacitance of advanced semiconductor technologies \cite{Zhao2015_SEU_AdvancedIC}.

\subsubsection{Single Event Upsets (SEUs)}

The principal threat to \glspl{fpga} reliability is the \textit{Single Event Upset (SEU)}, a non-destructive event where a single particle strike flips the state of a memory bit \cite{Wilson2025,Yaman2022,leipnitz2015}. In \gls{sram}-based \glspl{fpga}, \glspl{seu} are a major concern because altered configuration bits can permanently change the implemented logic and routing, leading to persistent malfunctions \cite{Quinn2017_RadiationEffectsReconfigurableFPGAs}, as illustrated in Figures~\ref{fpga-seu-and} and~\ref{fpga-3upsets-cram}.

\subsubsection{\glsentrytext{see} Induced System Failure Types}

When a \gls{seu} hits an essential or critical bit of the \gls{fpga}'s \gls{cram}, it could change the implemented circuit, altering the expected behavior of the affected area.

The change could affect any of the configurable elements of \gls{fpga}, such as the state of the interconnection switches, the clock configuration, the contents of \gls{bram}, the entries in \gls{lut}, or the specific state of the hardware configuration.

Figure~\ref{fpga-seu-and}(a) illustrates a scenario in which a 2-input \gls{lut} is configured by the \gls{cram} bits to describe an $AND$ gate and the \gls{lut} inputs are connected to the inputs $A$ and $B$ by an interconnection switch.

From Table~\ref{tab:logic_gates}, it is evident that the implemented circuit acts as an $AND$ gate, exhibiting the exact behavior described for the values of its inputs.

Then in Figure~\ref{fpga-seu-and}(b), a \gls{seu} is represented, changing the first value of the 2-input \gls{lut} from $0$ to $1$. Now, the behavior of the circuit changes, as demonstrated in Table~\ref{tab:logic_gates}, from an $AND$ gate to a $XNOR$ gate.

Figure~\ref{fpga-seu-and}(c) illustrates another possible scenario, where an interconnection switch is hit by a \gls{seu}, disconnecting the $A$ input from the \gls{lut}. As the input is left floating, the output result is unpredictable. The unconnected input might drift between high and low logic values, depending on nearby static fields. It may drift to an intermediate voltage, partially switching the output and causing excessive gate heating. Or, the output could oscillate between high and low logic values.

\begin{figure}[ht]
\centering
\includegraphics[width=0.75\textwidth]{Cap3/1-s2.0-S014193312300087X-gr1_lrg.jpg}
\caption{Conceptual representation of a \acrshort{seu} occurring in a \acrshort{fpga} \acrshort{lut}, where a single configuration bit upset modifies the truth table and changes the output behavior. Adapted from \textcite{Mousavi2023_MTTR_FPGA_Scrubbing}.}\label{fpga-seu-and}
\end{figure}

\begin{table}[ht!]
\centering
\caption{Truth Tables for AND and XNOR Logic Gates.}
\label{tab:logic_gates}
\[
\begin{array}{c c  c @{\hskip 3cm} c c  c}
\hline
\multicolumn{3}{l}{\textbf{AND Gate}} & \multicolumn{3}{c}
{\textbf{XNOR Gate}} \\
\text{In1} & \text{In2} & \text{Out} & \text{In1} & \text{In2} & \text{Out} \\
\hline
0 & 0 & 0 & 0 & 0 & 1 \\
0 & 1 & 0 & 0 & 1 & 0 \\
1 & 0 & 0 & 1 & 0 & 0 \\
1 & 1 & 1 & 1 & 1 & 1 \\
\hline
\end{array}
\]
\end{table}

\begin{figure}[ht]
\centering
\includegraphics[width=0.75\textwidth]{Cap3/seu-sb-mb.png}
\caption{Representations of \acrshort{sbu} and \acrshort{mbu} in the \acrshort{fpga} \acrshort{cram}. Reproduced from \textcite{Aguiar2025_SEE_Space_to_Accelerator}.}\label{fpga-seu-and-sbu-mbu}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[width=0.75\textwidth]{Cap3/fncom-17-1268374-g0001.jpg}
\caption{Representation of different types of upsets in a \acrshort{fpga} \acrshort{cram}. Reproduced from \textcite{Xie2023_HybridGrainedScrubbing}.}\label{fpga-3upsets-cram}
\end{figure}

\section{Reliability Challenges in SRAM-based FPGAs}

\gls{sram}-based \glspl{fpga} are widely adopted for their flexibility, performance, and reconfigurability. However, their configuration memory (\gls{cram}) and user logic are highly susceptible to soft errors induced by radiation, electromagnetic interference, or aging effects. These transient faults can alter logic functionality or corrupt stored data, potentially leading to malfunction or complete system failure. Understanding the nature, frequency, and impact of these faults is critical to developing effective mitigation strategies.

The concept of soft error criticality describes the potential of \gls{fpga} bits to cause design failures. Upsets in unused regions generally pose a lower risk, as these bits are not expected to affect functionality; however, soft errors could still impact the design if unused elements become inadvertently enabled. Bits configured for the implemented design, whether set to zero or one, are referred to as essential bits. Single-bit upsets in essential bits may be masked by the design, but multiple upsets can accumulate and overcome this inherent protection, potentially leading to errors. Critical bits are those whose flipping can directly cause a system failure, meaning that a single-bit upset in such a bit may compromise the design \cite{Adria2023}. Figure~\ref{fpga-bits-definition} illustrates the classification of the various types of \gls{fpga} bits.

\begin{figure}[ht]
\centering
\includegraphics[width=0.75\textwidth]{Cap3/fpga-bits-definition.png}
\caption{Classification of configuration bits in the \acrshort{fpga} \acrshort{cram} based on their criticality. Reproduced from \textcite{Adria2023}.}\label{fpga-bits-definition}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{N-Modular Redundancy (NMR)}
\gls{nmr} is a fault-masking technique in which multiple identical modules operate in parallel and a majority voter determines the correct output \cite{Adria2023,7948063}. Although \gls{tmr} is the most common case, extending to higher-order NMR provides increased fault tolerance at the expense of resource overhead. This section explains the mathematical basis of \gls{nmr}, voter design considerations, fault coverage properties, and limitations with respect to permanent resource degradation.

\gls{nmr} is a fundamental redundancy-based technique used to enhance a system’s resilience to faults. It generalizes the well-known \gls{tmr} scheme, where $N = 3$.

\subsection{Architecture and Principle}
The fundamental operation of \gls{nmr} relies on spatially redundant hardware, employing $N$ copies of a module or functional unit operating in parallel. All redundant modules receive identical input data, and their outputs are directed to a voter or majority voting circuit \cite{Tarrillo2014_Power_nMR}. This voter determines the final system output based on the majority result, thereby masking any single disagreement. For the system to maintain correct functionality, the absolute majority of the $N$ units must remain fault-free. To guarantee error correction capability through majority voting, $N$ is typically chosen as an odd number.

\subsection{Benefits and Context}
\gls{nmr} architectures are primarily utilized to mask faults and significantly enhance system reliability and availability. Employing redundancy beyond $N = 3$ (e.g., Quad-MR or 7MR) enables tolerance to multiple simultaneous or accumulated faults, such as \glspl{mbu}, which are increasingly common in modern integrated circuits. These upsets raise the likelihood that more than two modules may fail concurrently, thus requiring higher levels of redundancy for continued operation.

\gls{nmr} can also be viewed as a specific case of a $R$-out-of-$N$ redundancy system \cite{Yaman2022}. An \textit{R-out-of-N} redundancy scheme consists of $N$ redundant elements (such as modules, processors, or sensors), and the system is considered operational if at least $R$ of them function correctly. In contrast, if fewer than $R$ units are operating properly, the system is deemed to have failed.

\subsection{Implementation Overheads}
The main drawback of implementing \gls{nmr} lies in its overhead, primarily due to increased resource utilization and power consumption \cite{Tarrillo2014_Power_nMR}. Theoretically, power scales linearly with the number of redundant modules ($N$ times the power of a single circuit) \cite{Adria2023}. However, when implemented in a single \gls{sram}-based \gls{fpga}, this increase is often non-linear and considerably lower than predicted for equivalent \gls{asic} designs \cite{Tarrillo2014_Power_nMR} \. The applicability of \gls{nmr} is inherently limited by the available resources in the target \gls{fpga} device \cite{OliveiraKastensmidt2023,Adria2023}.

\subsection{Coarse-Grain Triple Modular Redundancy (CGTMR)}
\label{sec:cgtmr}

\gls{cgtmr}, also referred to as \textit{block-level TMR}, applies redundancy at a high level of design hierarchy, such as an entire system module or component \cite{Yaman2022}.

\paragraph{Implementation}
In \gls{cgtmr}, the entire component or module is triplicated as a complete functional block. The voting mechanism is performed only on the external outputs of the replicated blocks, rather than within the internal logic. This simplifies integration and minimizes design modifications, as the redundancy is confined to the system’s top-level boundaries \cite{Adria2023,Wilson2025}.

\paragraph{Granularity Example}
In the context of a processor, \gls{cgtmr} corresponds to replicating the entire processor core as a single block and performing voting at the output interface \cite{Adria2023}. For example, core-level \gls{tmr} applied to a \gls{riscv} processor can be implemented as a wrapper that encompasses three identical processor cores, without changes to their internal architecture. This approach facilitates the adoption of fault-tolerance in complex designs while maintaining modularity and reusability \cite{Yaman2022}.

Figure~\ref{fig:cgtmr} illustrates an example of a \gls{cgtmr} implementation.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.75\linewidth]{Cap3/cgtmr.png}
    \caption{Structural representation of the \acrlong{cgtmr}}
    \label{fig:cgtmr}
\end{figure}

\subsection{Fine-Grain Triple Modular Redundancy (FGTMR)}
\label{sec:fgtmr}

Fine-grain redundancy applies modular redundancy at a lower and more detailed level of the circuit architecture \cite{Yaman2022}. This approach encompasses several variations, depending on the extent to which the internal logic and circuit elements are protected.

\subsubsection{Fine-Grain Distributed TMR (FDTMR)}
\label{sec:fdtmr}

\gls{fdtmr} represents the most comprehensive form of fine-grain \gls{tmr}, involving widespread triplication and distributed voting throughout the circuit structure. \cite{OliveiraKastensmidt2023,Adria2023}.

\paragraph{Implementation}
In \gls{fdtmr}, all internal submodules of the design are triplicated \cite{Adria2023}. For \glspl{sram}-based \glspl{fpga}, this form of fine-grain redundancy involves triplicating the fundamental programmable primitives such as Flip-Flops (FFs), \glspl{lut}, \glspl{bram}, and \glspl{dsp}. Triplicated voters are inserted between these primitives to ensure continuous error masking within the circuit \cite{Wilson2021_TMRVexRiscv,wilson2020}.

% \paragraph{Voting}
% Voting in \gls{fdtmr} is typically performed at multiple internal stages of the design \cite{Yaman2022}. Feedback voters may also be added to Flip-Flops that incorporate feedback logic, enabling localized error correction at that stage. This distributed voting strategy enhances fault coverage but also increases design complexity and resource usage. In practice, such implementations are often automated by specialized software tools capable of performing netlist-level triplication and voter insertion \cite{OliveiraKastensmidt2023,Adria2023}.

Figure~\ref{fig:fgtmr} illustrates an example of a \gls{fdtmr} implementation.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.75\linewidth]{Cap3/fgtmr.png}
    \caption{Structural representation of the \acrlong{fgtmr}}
    \label{fig:fgtmr}
\end{figure}

\subsection{Voters}

In \gls{nmr} architectures, the \emph{voter} is a fundamental component responsible for determining the final output of the system based on the responses of redundant modules. Mediates the outputs of multiple redundant units to produce a single reliable system response, serving as the coupling element between redundancy and output. Voters are indispensable in both static and hybrid redundancy schemes.

The main functions of voters include the following:

\begin{itemize}
    \item \textbf{Generating Consensus:} Voters receive outputs from the redundant modules and compare them to determine a consensus result, typically based on a majority of matching outputs \cite{Yaman2022,7948063,Dorflinger2022}.
    \item \textbf{Masking Errors:} In a \gls{tmr} configuration, the voter masks single faults by selecting the majority output from the correctly functioning modules, maintaining system reliability \cite{7948063,Yaman2022,Neves2009,OliveiraKastensmidt2023,Wilson2021_TMRVexRiscv}.
    \item \textbf{Propagating the Correct Signal:} Once a consensus is established, the voter propagates the signal identified as correct to the subsequent system stage \cite{Romero2015}.
    \item \textbf{Defining Output Conditions:} In an $N$-modular system, a consensus is achieved when at least $N/2 + 1$ modules produce matching outputs. If this condition is not met, the system is considered to have no valid consensus \cite{Neves2009}.
\end{itemize}

\subsubsection{Voter Architectures and Vulnerabilities}
\label{sec:voter_types}

Voters play a central role in ensuring reliable outputs in \gls{nmr} systems by mediating between redundant modules. Different voter architectures have been proposed to address specific design constraints and reliability requirements:

\begin{itemize}
    \item \textbf{Majority or Bit-by-Bit Voters:} The majority voter implements the majority function using standard logic gates, such as AND/OR or NAND structures, to determine the final system output based on the majority of identical input values. In wide data buses, this logic can be applied bit-by-bit, comparing each bit of the output individually. Bit-by-bit majority voters are simple and efficient for small or low-throughput systems, but may become less effective in high-bandwidth or complex designs because of the lack of word-level integrity verification.

The Boolean equation for a three-input majority voter can be expressed as:
    \begin{equation}
        Q = AB + AC + BC
        \label{eq:maj_voter}
    \end{equation}
    where $A$, $B$, and $C$ represent the output of the redundant modules, and $Q$ is the resulting output voted.
    
For a general case with $N$ redundant modules, the majority function can be defined as
    \begin{equation}
        Q =
            \begin{cases}
                1, & \text{if } \displaystyle \sum_{i=1}^{N} x_i \geq \left\lceil \frac{N}{2} \right\rceil, \\[6pt]
                0, & \text{otherwise.}
            \end{cases}
    \label{eq:n_input_majority}
    \end{equation}
    where $x_i$ represents the binary output of the $i$-th module, and $Q$ is asserted when the majority of inputs are logical ‘1’.
    
    \item \textbf{Word Voter:} Proposed by \textcite{Mitra2000}, it is designed to overcome the limitations of bit-by-bit voters in wide memory buses, the word voter incorporates additional circuitry to generate an error signal when data integrity is compromised, even by a single-bit fault. This mechanism improves reliability by revealing inconsistencies that conventional voters may otherwise mask. The operation of a three-input word voter can be expressed as:
    
    \begin{equation}
    \begin{aligned}
    W_{\text{out}} &=
    \begin{cases}
    W_1, & \text{if } (W_1 = W_3), \\[4pt]
    W_2, & \text{if } (W_1 \neq W_3), \\[4pt]
    \text{undefined}, & \text{otherwise,}
    \end{cases} \\[6pt]
    E_{\text{flag}} &= 
    \begin{cases}
    1, & \text{if } (W_1 \neq W_2) \lor (W_1 \neq W_3) \lor (W_2 \neq W_3), \\[4pt]
    0, & \text{otherwise.}
    \end{cases}
    \end{aligned}
    \label{eq:word_voter_mitra}
    \end{equation}

where $W_1$, $W_2$, and $W_3$ are the $m$-bit words from the three redundant modules, $W_{\text{out}}$ is the output word voted and $E_{\text{flag}}$ indicates a mismatch between all outputs of the modules.

This approach enhances data integrity by enabling fault detection at the word level, allowing the system to identify inconsistencies that bit-by-bit voting may overlook.
    
    \item \textbf{Self-Adapted Voter (SAv):} Proposed by \textcite{Tarrillo2014, Tarrillo2014_Power_nMR}, it is designed to tolerate multiple accumulated faults. The SAv determines the output considering only the responses of healthy modules as part of the majority voting population. It computes the fault-free output (FFO) bit-by-bit based on the summation of outputs from fault-free modules and their total count.
\end{itemize}

\begin{table}[H]
\centering
\small
\caption{Comparison of fault-free and faulty outputs across different modules, including the resulting decisions from both bit-by-bit and word-level voters. Adapted from \textcite{Yaman2022}.}
\label{tab:voter_comparison}
\begin{tabular}{p{3cm} p{2.5cm} p{2.5cm} p{2.5cm} p{2.5cm}}
\toprule
\textbf{Module} & 
\textbf{0-Module Faulty} & 
\textbf{1-Module Faulty} & 
\textbf{2-Module Faulty} & 
\textbf{3-Module Faulty} \\
\midrule
A & 000 & 001 & 001 & 100 \\
B & 000 & 000 & 010 & 001 \\
C & 000 & 000 & 000 & 010 \\
\textbf{Majority Voter} & 000 & 000 & 000 & 000 \\
\textbf{Word Voter} & 000 & 000 & \textit{No majority} & \textit{No majority} \\
\bottomrule
\end{tabular}
\end{table}

In Table~\ref{tab:voter_comparison}, the design and functionality of the word and bit-by-bit voter architectures are compared. The \emph{word voter} is specifically developed to address limitations associated with bit-by-bit voters in wide memory buses. Unlike conventional designs, word voters incorporate additional circuitry to generate an error signal when data integrity is compromised, even by a single-bit fault. This enhancement significantly improves reliability by detecting inconsistencies that traditional bit-by-bit voters may fail to expose, thereby increasing the overall robustness of the redundant system.

\subsubsection{Voter Vulnerabilities and Mitigation}
Voters are inherently critical components, as they introduce a \gls{spof} within redundant systems \cite{Tarrillo2014,leipnitz2015,Yaman2022,Oliveira2017}. A fault in the voter can compromise the entire redundancy scheme by propagating erroneous results to the system output. For example, in a \gls{tmr} configuration, an omission in the voter logic renders redundancy ineffective \cite{Kastensmidt2006}, allowing faulty data to dominate the output. The reliability of the voter directly determines the overall reliability of the system. Enhancing voter robustness through techniques such as redundancy within the voter, temporal voting, or error detection mechanisms is essential to maintain system dependability.

\section{Dynamic Partial Reconfiguration (DPR)}
\gls{dpr} enables the selective reprogramming of specific \gls{fpga} regions during runtime without disrupting the operation of unaffected modules \cite{Bonna2021}. By targeting only the faulty portions of the design, \gls{dpr} reduces downtime and resource waste compared to full device reprogramming. This section describes the internal mechanisms of \gls{dpr}, design partitioning strategies, and how it complements redundancy to achieve self-repairing \gls{fpga} systems.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Cap3/dpr-xilinx.png}
    \caption{Basic principle of \acrshort{dpr} in \acrshort{fpga} devices. Reproduced from \cite{Xilinx_UG909_PR}.}
    \label{fig:dpr-xilinx}
\end{figure}

\gls{dpr} is a powerful feature widely adopted in modern embedded systems and hardware prototyping, particularly in designs based on \glspl{sram}-based \glspl{fpga}. It enables the modification of hardware functionality at runtime without interrupting the operation of the remaining system components \cite{Ghaffari2014_FastSRAM_FI,ZanoneSaotome2023,Wilson2020_VideoPipelines}.

\subsection{Definition and Mechanism}
\gls{dpr} allows specific regions of the \gls{fpga} fabric to be reconfigured while other regions continue operating normally \cite{Bonna2021,ZanoneSaotome2023,Barbosa2021}. This capability makes it a cornerstone of runtime-reconfigurable embedded systems, enabling computing devices to modify their hardware architecture dynamically according to application demands.

The main characteristics of \gls{dpr} include:
\begin{itemize}
    \item \textbf{Selective Modification:} Enables the reconfiguration of a defined region within the \gls{fpga} without interrupting the operation of the rest of the device \cite{Barbosa2021,Wilson2020_VideoPipelines}.
    \item \textbf{Partitioning:} The programmable area can be divided into one or more partitions, where each partition can be reconfigured independently \cite{Bonna2021}. These reconfigurable regions are typically defined using Vivado’s \texttt{pblock} feature \cite{Wilson2020_VideoPipelines}.
    \item \textbf{Static and Dynamic Logic:} \gls{dpr} separates the design into static (fixed) logic and dynamic (reconfigurable) logic. The static logic remains constant, while the dynamic logic—implemented in \glspl{dpr} can be replaced or updated at runtime \cite{Wilson2020_VideoPipelines}.
    \item \textbf{Partial Bitstreams:} Reconfiguration is performed by loading partial bitstreams, which contain only the configuration data for the reconfigurable partition, unlike full bitstreams that include both static and dynamic regions \cite{Yang2022_FaultInjectionUltrascale}.
\end{itemize}

Figure~\ref{fig:dpr-xilinx} illustrates the concept described above, where multiple partial bitstreams can coexist in external memory and dynamically loaded, one at a time, into the reconfigurable region of the \gls{dpr} setup.

\subsection{Implementation in FPGA Platforms}
Implementing \gls{dpr} requires dedicated configuration flows and access to the device’s configuration memory through specialized interfaces. The most common configuration interfaces include:

\begin{itemize}
    \item \textbf{Internal Configuration Access Port (ICAP):}  
    An internal hardware interface accessible through HDL primitives. The \gls{icap} allows rapid reconfiguration directly from within the programmable logic and is often employed in fault injection or fast module updates.

    \item \textbf{Processor Configuration Access Port (PCAP):}  
    Available on Xilinx Zynq and UltraScale+ \glspl{fpga}, the \gls{pcap} is managed by software running on the embedded ARM processor. It facilitates bitstream transfer between the Processing System (PS) and the Programmable Logic (PL) via DMA, enabling efficient runtime reconfiguration.

    \item \textbf{JTAG and SelectMAP:}  
    External configuration interfaces commonly used for debugging, testing, or initial configuration. While \gls{jtag} offers flexibility for development and validation, SelectMAP provides higher bandwidth for bitstream loading during operation.
\end{itemize}

Thus, \gls{dpr} provides a foundation for adaptive and fault-tolerant \gls{fpga} systems, enabling the replacement, recovery, or upgrade of hardware modules on demand without system downtime.

\section{Memory Scrubbing Techniques}
Configuration memory scrubbing is a proactive approach that periodically reads and corrects the \gls{fpga} configuration to prevent error accumulation.

\subsection{Scrubbing in SRAM-Based FPGAs}

According to \textcite{Wubs2023}, the primary method for correcting bit flips in the configuration memory of \glspl{fpga} based on \gls{sram} technology is \emph{scrubbing}. This process consists of rewriting corrupted configuration frames using a radiation-protected reference. Faults are identified either through continuous comparison between the current configuration memory and the reference, or by employing \glspl{ecc} mechanisms.

Two main approaches to scrubbing exist: internal and external. Internal scrubbers leverage the \gls{fpga}’s own resources and require no additional hardware but generally provide limited fault detection and correction capabilities. In contrast, external scrubbers offer higher performance and reliability, though they require dedicated external hardware to manage the process.

Scrubbing can be performed on the entire configuration memory (\emph{full scrubbing}) or on selected regions (\emph{partial scrubbing}). The latter is only feasible if the targeted area is physically isolated from the rest of the circuit to avoid interference. It is important to note that scrubbing merely prevents the accumulation of soft errors in configuration memory. Bit flips that occur between scrubbing cycles can still cause functional errors or incorrect output states, since there is an inevitable latency between fault occurrence and correction. Moreover, scrubbing does not address faults in user registers or embedded memories, which remain susceptible to radiation-induced effects~\cite{Wubs2023}.

As highlighted by \textcite{Adria2023}, \glspl{seu} in \glspl{fpga} may lead to persistent functional errors by altering the architectural configuration of the implemented design. To mitigate such effects and prevent fault accumulation, \gls{cram} scrubbing is a well-established corrective strategy. However, scrubbing does not prevent the occurrence of bit flips, nor can it fully mitigate the consequences of upsets affecting critical bits. Therefore, additional design-level mitigation mechanisms are typically employed to reduce single points of failure and enhance the system’s fault-masking capability.

Several scrubbing architectures have been proposed in the literature, mainly differing in their error detection methods, resource utilization, power consumption, and correction latency~\cite{heiner2008,Brosser2014,tonfat2015,7776929}. Scrubbing strategies are usually classified into two categories:
\begin{itemize}
    \item \textbf{Internal scrubbing:} The scrubber engine is implemented within the same \gls{fpga} that it monitors. This approach requires no additional hardware and provides high-speed detection and correction capabilities. An example is the \gls{semip}~\cite{amd2023sem}, which is integrated into most modern Xilinx devices. However, internal scrubbers remain vulnerable to \glspl{seu} that may affect their own logic or communication interfaces. Such upsets may cause the scrubber to become unresponsive, compromising its correction capability, especially in cases involving multiple simultaneous upsets~\cite{berg2008}, as illustrated in Figure~\ref{fig:scrubbing-int-ext}(a).
    \item \textbf{External scrubbing:} The scrubber controller is implemented on an external device. This architecture provides greater robustness and can manage multiple upsets more reliably, as it is isolated from the internal \gls{fpga} logic, as illustrated in Figure~\ref{fig:scrubbing-int-ext}(b).
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap3/scrubbing1.30.png}
    \caption{Different memory scrubbing techniques: (a) internal and (b) external.}
    \label{fig:scrubbing-int-ext}
\end{figure}

Figure~\ref{fig:scrubbing-soc} illustrates a scrubbing solution based on \gls{soc}, where the integrated ARM processor is used to scrub the \gls{sram}-based configuration memory of \gls{fpga}. This type of architecture is expected to become increasingly common, as most modern \glspl{fpga} integrate a hard processor core within the same die.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Cap3/scrubbing2-30.png}
    \caption{Scrubbing structure implemented using the \acrshort{soc}'s processor.}
    \label{fig:scrubbing-soc}
\end{figure}

However, \gls{cram} scrubbing, whether internal or external, does not protect volatile memory elements such as \glspl{bram}, distributed memories (\glspl{lutram}), and \glspl{ff}. Upsets in these dynamic elements must be addressed through complementary techniques such as redundancy, \gls{ecc}, or periodic resets to restore the initial state of the system. In more severe cases, such as \glspl{sefi} that affects the control logic or configuration interfaces \gls{fpga}, a power cycle may be required to restore normal operation.

\bigskip
\noindent
Although scrubbing plays a crucial role in preventing the accumulation of faults in configuration memory, it does not offer insight into how these issues affect system functionality or reliability at the architectural level. To evaluate and validate the effectiveness of mitigation techniques, researchers often employ \emph{\gls{fi}} campaigns. The next section explores \gls{fi} as an essential experimental approach for characterizing fault tolerance and assessing the dependability of \gls{fpga}-based systems.

\section{Fault Injection Principles}
Fault injection is an essential method to evaluate the robustness of fault-tolerant \gls{fpga} designs. By deliberately introducing controlled errors into the system, researchers can analyze failure modes, verify mitigation strategies, and quantify reliability metrics. This section explains fault injection models (bit-flip, stuck-at), implementation techniques (simulation-based, emulation-based, on-chip), and evaluation criteria.

\subsection{Fault Injection in FPGA-Based Systems}

According to \textcite{Adria2023}, \gls{fi} is an experimental technique used to deliberately introduce faults into a system to reproduce radiation-induced effects and evaluate the dependability of its design. It serves to identify vulnerable regions that require hardening and to validate the effectiveness of implemented fault-mitigation strategies. In radiation-tolerant applications, \gls{fi} is an essential step in characterizing failure mechanisms, validating recovery techniques, and assessing system-level robustness~\cite{Adria2023,leipnitz2015}.

Fault injection can be applied at various abstraction levels, including transistor, gate, register-transfer (RTL), or system level~\cite{anghel2007}. For example, in a soft processor implemented in a \gls{sram}-based \gls{fpga}, bit flips injected into \gls{cram} affect the processor’s \gls{rtl} architecture, while faults injected into \glspl{bram} influence the execution of applications at the user-level~\cite{Adria2023}.

Different techniques can be used to perform fault injection, depending on the level of realism, controllability, and available hardware resources. The three main approaches are as follows:

\begin{itemize}
    \item \textbf{Physical fault injection:} faults are induced through direct physical means, such as heavy-ion or proton irradiation, laser strikes, or voltage and electromagnetic perturbations. This method offers the highest realism since it reproduces actual radiation effects, but requires specialized facilities and equipment, often resulting in limited controllability and higher cost~\cite{Adria2023,Fibichi2019}.
    
    \item \textbf{Simulation-based fault injection:} faults are introduced within simulation environments or hardware description language (HDL) models. This approach provides full observability and high controllability, enabling exhaustive testing at the cost of reduced execution speed and limited hardware fidelity~\cite{Adria2023,Fibichi2019}.
    
    \item \textbf{Emulation-based fault injection:} faults are injected directly into a running hardware prototype, typically implemented on an \gls{fpga}. This technique offers a balance between accuracy and performance, allowing real-time experimentation under conditions close to the actual operation. It enables efficient evaluation of mitigation schemes such as redundancy, scrubbing, and dynamic partial reconfiguration (\gls{dpr})~\cite{Adria2023,Fibichi2019}.
\end{itemize}

Fault injection can also be classified based on the injection controller architecture. Hardware-based injectors use an external module that introduces faults without disturbing the system’s normal operation, while software-based injectors operate within the target device and may temporarily pause its execution to perform the injection~\cite{velazco2000}. The latter are more intrusive but easier to implement, whereas hardware injectors are non-intrusive and provide better temporal precision.

In addition, fault injection strategies can be either \emph{deterministic} or \emph{random}. Deterministic injections target predefined configuration bits or memory elements, enabling controlled evaluation of specific fault locations. Random injections, in contrast, select bits probabilistically to emulate stochastic radiation-induced events. Exhaustive single-bit injections are often used to identify critical configuration bits in the design, while accumulative random injections allow faults to build up over time, offering insight into the system’s behavior under multiple concurrent upsets~\cite{benevenuti2019}.

The temporal aspect of fault injection is also crucial. The timing of an injected fault within a clock cycle or during software execution can greatly influence whether it propagates, becomes masked, or leads to a system failure~\cite{quinn2013}. Therefore, a realistic fault-injection campaign must statistically cover both spatial and temporal domains to faithfully reproduce radiation-induced behavior.

Among these methodologies, emulation-based \gls{fi} has become particularly valuable for evaluating \gls{fpga}-based systems. It allows for real-time fault-effect observation, short testing cycles, and validation of fault-tolerance strategies such as modular redundancy, scrubbing, and \gls{dpr}. In this work, \gls{fi} is employed as a key validation mechanism to characterize the fault tolerance of \gls{fpga}-based designs and to assess the reliability enhancements achieved through redundancy and \gls{dpr} techniques.

\section{Physical Mitigation Techniques}

Physical mitigation can take several forms, including traditional barriers, technological fabrication improvements, and layout- or placement-level design strategies. These approaches aim to reduce the impact of radiation by either preventing particle interaction with sensitive regions or by hardening the device structure to withstand such interactions.

\subsection{Physical Barriers and Material-Based Hardening}
Historically, physical protection through shielding was one of the first techniques used to mitigate \glspl{seu} in spacecraft, effectively reducing the incident particle flux. However, the efficiency of shielding depends strongly on the type of radiation involved:
\begin{itemize}
    \item Shielding is effective against alpha and beta particles but has limited effect against gamma rays, neutrons, or heavy ions \cite{Barbosa2021}.
    \item Even with duplication or triplication of shielding layers, the reduction in proton-induced effects is often marginal \cite{Barbosa2021}..
    \item Additional insulating and polymer-based materials have been explored to mitigate soft errors, though their effectiveness remains application-dependent \cite{Rogenmoser2023_HMR,Barbosa2021}.
\end{itemize}

At the device manufacturing level, protection is achieved through \gls{rhbp}. These techniques mitigate \gls{tid} and \gls{sel} effects by modifying fabrication processes, such as using \gls{soi}, \gls{bicmos}, or other wide-bandgap technologies. \gls{rhbp} acts directly on oxide and interface charge-retention characteristics, while structural modifications like isolation wells or current-limiting transistors can prevent destructive latch-up events \cite{Barbosa2021}..

\subsection{Hardening by Physical Design and Layout}
Another level of mitigation, known as \gls{rhbd}, focuses on the physical layout of the circuit to improve resilience against radiation effects \cite{Rogenmoser2023_HMR}:
\begin{itemize}
    \item \textbf{Layout Modification:} Increasing the spacing between sensitive nodes reduces charge sharing from particle strikes, while enlarging transistors in critical paths increases their critical charge ($Q_{\text{crit}}$), enhancing radiation tolerance \cite{Battezzati2010}.
    \item \textbf{SEL Detection and Limitation:} External circuitry on the power rails can detect abnormal current spikes caused by latch-up and act as resettable fuses or current limiters \cite{Battezzati2010}.
    \item \textbf{SET Mitigation:} Proper contact placement and signal routing can help cancel transient pulses generated by radiation events \cite{Sharma2020_IPFA_MBU}.
\end{itemize}

\subsection{SEU-Aware Placement}
A modern design-flow-level mitigation approach, proposed by \textcite{Wilson2025}, is the \gls{seu}-aware placement, which applies physical placement constraints during the implementation phase:
\begin{itemize}
    \item This method improves fault tolerance without modifying the \gls{hdl}'s design source code.
    \item Using \gls{xdc} or \gls{tcl} scripts, designers can control the placement of logic elements, registers, and routing paths to minimize sensitivity to \glspl{seu}.
    \item It also enables \textit{domain striping}---the physical separation of redundant modules---and prevents optimization tools from merging triplicated elements such as global clock buffers, thereby maintaining redundancy integrity.
\end{itemize}

Physical protection and mitigation strategies, such as shielding and material hardening, are commonly employed to reduce radiation-induced effects at the device level by attenuating or blocking incident particles, thereby minimizing the probability of single-event phenomena. Although these techniques play an important role in enhancing device resilience, this research does not focus on such approaches. Mitigations based on external barriers or material hardening are beyond the scope of this work, which instead emphasizes architectural and logic-level strategies, particularly those involving \gls{nmr} and \gls{dpr}.

\section{Summary and Relevance to This Work}
\label{sec:cap3-summary}

This chapter presented the theoretical foundations required to understand the techniques and mechanisms explored in this dissertation. It started by introducing the internal architecture of \glspl{fpga}, highlighting how the reconfigurable nature of \gls{sram}-based devices provides flexibility at the cost of increased susceptibility to radiation-induced faults. The structure of \gls{cram}, the organization of its frames and the concept of essential and critical bits were described to emphasize the relationship between hardware configuration and the manifestation of faults.

The discussion of radiation effects and the various types of \glspl{see} provided a physical basis for understanding how transient phenomena, such as \glspl{seu} and \glspl{mbu}, can alter the behavior of logic elements and routing resources. These effects directly motivate the adoption of architectural fault-mitigation mechanisms to preserve the functionality of the system under adverse conditions.

Among the mitigation techniques analyzed, \gls{nmr} emerged as a fundamental redundancy-based approach to mask transient faults through spatial replication and majority voting. Both coarse-grain and fine-grain implementations were reviewed, along with different voter architectures. This analysis supported the choice of redundancy as a key element of the fault-tolerance strategy proposed in this research. However, as discussed, redundancy alone cannot restore corrupted modules or prevent long-term resource degradation, requiring complementary recovery mechanisms.

\gls{dpr} was therefore introduced as a dynamic reconfiguration strategy that enables in-system repair of faulty modules without interrupting the operation of unaffected regions. By isolating reconfigurable partitions and managing partial bitstreams, \gls{dpr} provides a foundation for self-healing hardware architectures. Its integration with redundancy allows faulty replicas to be reprogrammed on demand, effectively combining fault masking with fault recovery.

Configuration-memory scrubbing was discussed as a preventive mechanism that periodically restores the integrity of the \gls{fpga} bitstream. Although effective in avoiding error accumulation, scrubbing alone cannot guarantee functional recovery from faults affecting more than one bit per frame at a given time, like in a \gls{mbu} or in the memories like \gls{bram}. This reinforces the need for a hybrid approach that integrates scrubbing with redundancy and dynamic reconfiguration.

Finally, the principles of \gls{fi} were explored as an experimental means to evaluate the dependability of fault-tolerant designs. \gls{fi} enables the controlled emulation of radiation effects, allowing quantitative analysis of fault coverage, recovery efficiency, and system resilience. In the context of this work, \gls{fi} serves as the primary validation tool for assessing the effectiveness of the proposed mitigation techniques, rather than a corrective mechanism. In other words, \gls{fi} is used for validation, not correction, providing empirical evidence of the robustness of the system without altering its operational behavior or configuration.

In summary, the theoretical elements presented in this chapter converge to support the design strategy adopted in this dissertation: the combination of spatial redundancy (\gls{nmr}), adaptive reconfiguration (\gls{dpr}), and continuous fault detection through scrubbing and \gls{fi}. These complementary techniques form the foundation of the proposed fault-tolerant architecture, which is detailed in chapter~\ref{sec:cap4}, where their practical implementation, integration, and experimental validation are described.

Figure \ref{fig:nmr-dpr-scrubbing-fi-hierarchy} illustrates how the mitigation techniques discussed complement each other to achieve system dependability. Spatial redundancy ensures fault masking, dynamic partial reconfiguration enables recovery, and scrubbing maintains configuration integrity—together forming a hybrid architecture evaluated through systematic fault-injection experiments.

\usetikzlibrary{calc}

\begin{figure}[ht]
\centering
\begin{adjustbox}{max width=\textwidth}
\begin{tikzpicture}[
    every node/.style={font=\small, align=center},
    process/.style={rectangle, rounded corners, minimum width=6cm, minimum height=1.4cm, draw=black, fill=blue!15, thick, font=\bfseries},
    result/.style={rectangle, rounded corners, minimum width=6cm, minimum height=1.6cm, draw=black, fill=green!20, thick, font=\bfseries},
    labeltext/.style={font=\footnotesize, align=center},
    arrow/.style={thick,->,>=stealth}
]

% --- Base node (bottom) ---
\node (fi) [process] {Fault Injection (FI)};

% --- Stack vertically using coordinates ---
\node (scrub) [process] at ($(fi)+(0,2.8cm)$) {Configuration Memory Scrubbing};
\node (dpr) [process] at ($(scrub)+(0,2.8cm)$) {Dynamic Partial Reconfiguration (DPR)};
\node (nmr) [process] at ($(dpr)+(0,2.8cm)$) {N-Modular Redundancy (NMR)};
\node (system) [result] at ($(nmr)+(0,2.8cm)$) {Reliable FPGA System};

% --- Arrows between layers (right-shifted labels) ---
\draw[arrow] (fi) -- node[labeltext, right, xshift=2cm]{\textbf{Evaluates and validates}\\fault-tolerance effectiveness} (scrub);
\draw[arrow] (scrub) -- node[labeltext, right, xshift=2cm]{\textbf{Prevents accumulation}\\of soft errors in configuration} (dpr);
\draw[arrow] (dpr) -- node[labeltext, right, xshift=2cm]{\textbf{Recovers faulty modules}\\during runtime (self-repair)} (nmr);
\draw[arrow] (nmr) -- node[labeltext, right, xshift=2cm]{\textbf{Masks transient faults}\\via spatial redundancy} (system);

% --- Left-side conceptual labels ---
\node[labeltext] (faulttol) at ($(nmr)+(-6.0cm,0)$) {\textbf{Fault Masking}};
\node[labeltext] (reconf) at ($(dpr)+(-6.0cm,0)$) {\textbf{Fault Recovery}};
\node[labeltext] (maint) at ($(scrub)+(-6.0cm,0)$) {\textbf{Fault Prevention}};
\node[labeltext] (eval) at ($(fi)+(-6.0cm,0)$) {\textbf{Fault Evaluation}};

% --- Connect conceptual labels with dashed lines ---
\draw[dashed, gray] (faulttol.east) -- (nmr.west);
\draw[dashed, gray] (reconf.east) -- (dpr.west);
\draw[dashed, gray] (maint.east) -- (scrub.west);
\draw[dashed, gray] (eval.east) -- (fi.west);

\end{tikzpicture}
\end{adjustbox}
\caption{Hierarchical relationship among \acrlong{nmr}, \acrlong{dpr}, scrubbing, and \acrlong{fi}, showing how each layer contributes to the overall dependability of the \acrshort{fpga}-based system.}
\label{fig:nmr-dpr-scrubbing-fi-hierarchy}
\end{figure}
