%\section{Results and Analysis}
\label{sec:cap5}

This chapter presents the experimental results obtained from the proposed methodology and analyzes their significance. The discussion includes performance evaluation, \gls{fi} results, comparison with reference approaches, and an assessment of the reliability improvements achieved.

\section{Experimental Setup}

The software and hardware environments used in this research are described in \hyperref[sec:cap4-material]{Section~\ref*{sec:cap4-material} -- \textit{FPGA Platform and Toolchain}}. 
Figure~\ref{fig:setup-diagram} presents the connection diagram of the experimental setup used to conduct the tests, while Figure~\ref{fig:setup-pic} shows the actual laboratory configuration adopted during this work. 
The \href{https://ftdichip.com/products/ft2232hq/}{FT2232 communication module} was connected to the \href{https://pynq.readthedocs.io/en/v2.6.1/pynq_libraries/pmod.html}{\gls{pmod}} interface of the \href{https://www.amd.com/en/corporate/university-program/aup-boards/pynq-z2.html}{PYNQ-Z2} board, providing a dual-channel USB-to-serial bridge between the host computer and the \gls{fpga} system.


\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/setup-diagram.png}
    \caption{Interconnection diagram of the main board and the USB-to-Serial interface module.}
    \label{fig:setup-diagram}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{Cap5/setup.jpg}
    \caption{Experimental setup showing the main board (center) and the USB-to-Serial interface module (upper right).}
    \label{fig:setup-pic}
\end{figure}

For a detailed explanation of this experimental setup, see \hyperref[sec:ref-design-arch]{Section 4 - Reference Design Architecture}, \hyperref[sec:fi-strategy]{Section 4 - Fault Injection Strategy} and particularly Figure~\ref{zynq-paper-arch} for a detailed block diagram of the implemented design.

% \section{Baseline Performance Evaluation}
% Before introducing fault-tolerance mechanisms, the system performance is evaluated under normal conditions. This subsection discusses metrics such as resource utilization, operating frequency, and execution latency to establish a baseline reference.

\section{Partial Reconfiguration Results}

This section discusses the \gls{dpr} results, mainly in the reprogramming speed and size of partial bitstreams.

\begin{table}[H]
\centering
\caption{Summary of \acrlong{pr} throughput and configuration time with different \acrshort{dma} settings}
\label{tab:pr_time}
\begin{tabular}{cccc}
\toprule
\textbf{Condition} & \textbf{Time ($\mu$s)} & \textbf{Throughput (Mb/s)} & \textbf{Cache} \\
\midrule
First \gls{dpr} & 897 & 143 & Enabled \\
All others \gls{dpr} & 1.35 & 95195 & Enabled \\
First \gls{dpr} & 1186 & 108 & Enabled and invalidated \\
All others \gls{dpr} & 576 & 222 & Enabled and invalidated \\
First \gls{dpr} & 984 & 130 & Disabled \\
All others \gls{dpr} & 6 & 21117 & Disabled \\
\bottomrule
\end{tabular}
\end{table}

\textcite{Sultana2021} reports that the theoretical throughput of the \gls{pcap} interface is 400~Mb/s when operating on a 32-bit platform, achieving an average throughput of approximately 140~Mb/s. This result is closely aligned with the performance observed for the first \gls{dpr} in this study, as shown in Table~\ref{tab:pr_time}.

According to the results in Table~\ref{tab:pr_time}, during the first \gls{pr}, the achieved throughput approaches the theoretical value. However, from the second reconfiguration onward, certain configurations exhibit unrealistically high speeds. This behavior was identified as a side effect of the small bitstream size used for \gls{pr} and the \gls{ddr} cache present on the Zynq device. When the cache is enabled, write speeds of up to 96~Gb/s can be observed. However, if the cache is explicitly invalidated before each \gls{pr} operation, the throughput stabilizes near the average value and remains below the theoretical limit.

This phenomenon occurs because \gls{pcap} is designed to operate via \gls{dma} transfers from Zynq's \gls{ddr} memory, thus utilizing the cache unless it is explicitly disabled or invalidated.
Higher reconfiguration speeds could potentially be achieved using custom reconfiguration controllers, as demonstrated by ~\textcite{Vipin2014_ZyCAP} on Zynq devices.

For comparison, the total size of the full bitstream is 3.9~Mbit, while each partial bitstream corresponding to the math block is 109~kbit, representing around only 2.8\% of the full configuration size. This significant reduction in bitstream size directly impacts the reconfiguration time, allowing partial reconfiguration to be performed considerably faster than a full device reconfiguration.

This size difference makes \gls{dpr} particularly attractive as a fault-mitigation approach. If a fault is detected in any region of \gls{fpga} and is deemed uncorrectable, a partial reconfiguration can be issued while the static region remains operational. Since \gls{dpr} does not interfere with the execution of other regions, only a small portion of \gls{fpga} needs to be reprogrammed, allowing the system to recover functionality with minimal interruption.

Figure~\ref{fig:menu-blank&dpr-error}(a) shows the time required for the first \gls{dpr} and the application of the blank bitstream. The blanking configuration corresponds to a partial bitstream that contains no logic, serving only as a placeholder to ensure a clean reprogramming of the device. Figure~\ref{fig:menu-blank&dpr-error}(b) illustrates the error that occurs when applying \gls{dpr} without resetting \gls{semip} after a \gls{pr} has been executed. This behavior is discussed in detail in Section~\ref{sec:cap4}, particularly in Item~\ref{itemized-actions-for-dpr&sem}.

\begin{figure}[H]
    \centering
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/menu-blank.png}} 
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/menu-dpr-error.png}}
    \caption{(a) Menu selection for the \acrshort{pr} of the blanking bitstream. (b) Menu indication showing that the \acrshort{pr} failed to load a new bitstream.}
    \label{fig:menu-blank&dpr-error}
\end{figure}

Figure~\ref{fig:menu-mult&mult-ok}(a) shows the \gls{pr} of the \gls{hw} acceleration region as a multiplier using \gls{dpr}. This shows that the \gls{pr} process does not affect other areas of the \gls{fpga}, allowing the system to continue to operate normally. Figure~\ref{fig:menu-mult&mult-ok}(b) presents the correct results obtained from both multiplications, in \gls{hw} and \gls{sw}.

\begin{figure}[H]
    \centering
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/menu-mult.png}} 
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/mult-ok.png}}
    \caption{(a) Menu selection of the multiplier to be applied to the \acrshort{pr}. (b) Multiplication result verification on \acrshort{hw} and \acrshort{sw}.}
    \label{fig:menu-mult&mult-ok}
\end{figure}

Figure~\ref{fig:menu-add&add-ok}(a) shows the \gls{pr} of the \gls{hw} acceleration region into an adder using the \gls{dpr}. This shows that the \gls{pr} process does not affect other areas of the \gls{fpga}, allowing the system to continue to operate normally. Figure~\ref{fig:menu-add&add-ok}(b) presents the correct results obtained from both additions, in \gls{hw} and \gls{sw}.

\begin{figure}[H]
    \centering
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/menu-add.png}} 
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/add-ok.png}}
    \caption{(a) Menu selection of the adder to be applied through the \acrshort{pr}. (b) Addition result verification on \acrshort{hw} and \acrshort{sw}.}
    \label{fig:menu-add&add-ok}
\end{figure}

\subsection{Manual Fault Injection}

After performing the \gls{dpr}, it is possible to manually inject faults using the \gls{semip} to emulate \glspl{see}. For this purpose, the \gls{semip} is commanded via the serial interface to enter injection mode (``I''). Then, the target frame address is sent using the syntax ``N'' followed by the frame address, for example: \texttt{N C0003C440C}.

Figure~\ref{fig:menu-mult-error-fi}(a) shows that the multiplication, executed on \gls{hw}, produces completely incorrect results due to a \gls{fi} targeting a critical bit in frame \texttt{C0003C440C}. It is evident that the output differs from the corresponding \gls{sw} operation and does not match the expected result based on the input operands. Figure~\ref{fig:menu-mult-error-fi}(b) presents another example using different operands, demonstrating that although the output values vary, they remain incorrect.

\begin{figure}[H]
    \centering
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/mult-error.png}} 
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/mult-error2.png}}
    \caption{(a) \acrshort{hw} multiplication error after the injection of a bit flip in frame C0003C440C. (b) Multiplication results obtained with different operands.}
    \label{fig:menu-mult-error-fi}
\end{figure}

Figure~\ref{fig:add-error-fi}(a) shows that the addition, executed on \gls{hw},  produces completely incorrect results due to a \gls{fi} targeting a critical bit in frame \texttt{C0003C440C}. It is evident that the output differs from the corresponding \gls{sw} operation and does not match the expected result based on the input operands. Figure~\ref{fig:add-error-fi}(b) presents another example using different operands, demonstrating that although the output values vary, they remain incorrect.

\begin{figure}[H]
    \centering
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/error_add_after_injection_C0003C440C.png}} 
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/add_error_other_operand.png}}
    \caption{(a) \acrshort{hw} addition error after the injection of a bit flip in frame C0003C440C. (b) Addition results obtained with different operands.}
    \label{fig:add-error-fi}
\end{figure}

\section{Automated Fault-Injection Campaign Results}
This section presents the results of the automated fault-injection experiments. The effects of single-event upsets (SEUs) on configuration memory and logic are analyzed, highlighting error rates, propagation patterns, and observed system-level failures.

\subsection{Scrubbing and Fault Injection with a FIR Filter}

The first design done to test the \gls{fi} and the memory scrubbing, using the \gls{semip} was with a \gls{dmr} design, where the replicated modules were two \gls{fir} filters.

Figure~\ref{fig:automated_design} illustrates the automated \gls{fi} process. In the Linux terminal, the Python script is executed with a progress bar indicating the percentage of configuration frames already tested. The red square in the figure highlights the \gls{ila} trigger. During execution of \gls{fi}, the design can be monitored through this interface, allowing verification of the internal signals and whether they are affected by the injected bit flip. It is important to note that the monitoring via \gls{ila} is optional and serves only to visual inspect the faults. The design automatically transmits the test results over the serial interface, while the script handles fault injection, output verification, and logging of the frame address and the corresponding results.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/dut_fir/automated_design.png}
    \caption{Representation of the complete automation of the \acrlong{fi} process and the use of the \acrshort{ila} for real-time visualization and debugging of the design behavior during fault injection.}
    \label{fig:automated_design}
\end{figure}

Figure~\ref{fig:error-injection-fir} shows in detail the interface of the automation script. On the left side of the screen, it is possible to observe that the iteration speed is 63.57~iterations/s. This value must be divided by twelve to obtain the actual injection speed. The reason for this is the number of characters in each line of the input file used for fault injection. Each frame address consists of ten characters (e.g., \texttt{C0003C440C}), and each line in the file includes a line feed and a carriage return symbol, totaling twelve characters per injection command.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/dut_fir/error-injection.png}
    \caption{Python script and corresponding visualization showing the real-time progress of the \acrshort{fi} campaign}
    \label{fig:error-injection-fir}
\end{figure}

Figure~\ref{fig:fir_filter_equal} shows an example of a correct visualization of both filters. The error output is equal to zero, since both filters produce exactly the same values for each sample.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/dut_fir/fir_filter_equal.png}
    \caption{\acrshort{ila} waveform capture demonstrating the correct functionality of both filter modules, confirming synchronized operation and expected output behavior.}
    \label{fig:fir_filter_equal}
\end{figure}

Figure~\ref{fig:fir_filter_error} shows an example of an incorrect visualization of both filters. The error output is equal to one, as one of the filters produces a high-peaked response, resulting in different values for each sample.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/dut_fir/error-fir-filter.png}
    \caption{\acrshort{ila} waveform capture illustrating a \acrshort{fi} event that resulted in an erroneous output from the \acrshort{fir} filter, evidencing the effect of a configuration bit upset on functional behavior.}
    \label{fig:fir_filter_error}
\end{figure}

In a fault injection experiment, the failure sensitivity \( r \) is defined as the ratio between the number of resulting design failures \( k \) and the total number of injected faults \( n \), as expressed in Equation~\ref{eq:failure_sensitivity} \cite{Wilson2025}.

\begin{equation}
r = \frac{k}{n}
\label{eq:failure_sensitivity}
\end{equation}

Table~\ref{tab:fir_fi_summary} presents the general fault injection results for the \gls{fir} \gls{dut}. It shows the total number of essential bits within the Pblock region where the \gls{dut} was implemented. Using Equation~\ref{eq:failure_sensitivity}, the failure sensitivity \( r \) obtained is approximately \( 1.1 \times 10^{-3} \).

\begin{table}[H]
\centering
\caption{Summary of configuration bits associated with the \acrshort{fir} region and the critical upsets detected during the \acrlong{fi} campaign.}
\label{tab:fir_fi_summary}
\begin{tabular}{l r}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Total \gls{fpga} bits (\gls{cram}) & 25,697,632 \\
Total essential bits in the \gls{fir} region & 31,020 \\
Total injected bits & 31,020 \\
Critical bits detected: \gls{fir} error & 34 \\
Critical bits detected: AXI bus lock & \gls{na} \\
\bottomrule
\end{tabular}
\end{table}

It is important to note that the \gls{semip} operates with \gls{secded} \gls{ecc}. As shown in Table~\ref{tab:fir_fi_summary}, all single-bit faults injected were successfully corrected, allowing the \gls{fir} to continue operating seamlessly.

To further assess the system’s resilience, a set of \gls{mbu} campaigns was conducted to evaluate how long the design could sustain operation under random fault injection in the \gls{fpga} \gls{cram}. After only 50 bit flips, the \gls{fir} exhibited its first error. Since the \gls{semip} can correct only one error per frame, multiple upsets began to accumulate, eventually leading to system failure. After 3,564 injections, the design ceased functioning entirely—even the serial communication signal was corrupted, rendering the system completely inoperative.

\begin{table}[H]
\centering
\caption{Summary of \gls{mbu} fault injection campaign results for the \gls{fir} design.}
\label{tab:fir_fi_summary3}
\begin{adjustbox}{max width=\textwidth}
\begin{tabular}{l r}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Total \gls{fpga} configuration bits (\gls{cram}) & 25,697,632 \\
Total essential bits in the \gls{fir} region & \gls{na} \\
Total injected bits & 3,615 \\
Injections without error & 50 \\
Injections with error & 3,564 \\
Injections without response & 1 \\
\bottomrule
\end{tabular}
\end{adjustbox}
\end{table}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\linewidth]{Cap5/dut_fir/total-collapse-fir.png}
    \caption{Random \acrlong{fi} campaign on the \gls{fir} design showing progressive error accumulation with \acrlong{ms} disabled.}
    \label{fig:total-collapse-fir}
\end{figure}

Table~\ref{tab:fir_fi_summary3} summarizes the results obtained from the random fault injection campaign until the system became nonfunctional. Figure~\ref{fig:total-collapse-fir} illustrates the resulting build-up of errors, where the entire design becomes defective. The signals shown can be compared with those in Figure~\ref{fig:fir_filter_equal} to observe how far the defective outputs deviate from the correct reference behavior.

Using Equation~\ref{eq:failure_sensitivity}, the failure sensitivity \( r \) obtained is approximately \( 0.98\).

\subsection{DPR, Scrubbing and Fault Injection with Mathematical Functions}

After the successful implementation of scrubbing using \gls{semip} with \gls{dmr} \gls{fir} filters, the next design iteration incorporated \gls{dpr} into the system functionalities. To fully exploit the resources of \gls{soc}, a \gls{axi} controlled multiplier/adder module was developed. These hardware functions can be selected via a user menu and dynamically reconfigured within \gls{fpga}.

The same automated \gls{fi} campaign was applied; however, during the first attempt, it was not possible to inject faults into all essential bits of the \gls{pr} region, as some injections caused the \gls{ps} ARM processor to stall.

As presented in Table~\ref{tab:math_fi1_summary}, after 21,809 fault injections, the automated script stopped receiving responses from \gls{dut}. Since the device ceased sending status feedback, the script was manually terminated.

Figure~\ref{fig:mult-list-wo-reprogram} and Table~\ref{tab:math_fi1_summary} presents the output of the statistical report script, showing 16,000 configuration frames affected by bit flips that caused \gls{dut} to stop responding.

Initially, all these faults were assumed to correspond to a critical failure that stopped communication with the \gls{dut}. However, a detailed analysis revealed that a bit flip in the \gls{fpga} \gls{cram} corrupted the \gls{axi} bus, leading to a processor stall. The results of this first \gls{fi} campaign are summarized in Table~\ref{tab:math_fi1_summary}.

Once one of the injected frames caused the ARM processor to stall, all subsequent fault injections were affected, as the \gls{axi} bus stopped working, preventing  further communication with \gls{dut}. In other words, 16,000 error were flagged as unresponsive, but since the first one stalled the processor, the other 15,999 injection are meaningless.

The processor stalls is caused by the \gls{axi} bus, which operates based on a strict valid/ready signal's handshake between the master (e.g., ARM \gls{ps}) and the slave (e.g., the custom \gls{dpr} \gls{ip} core in the \gls{pl}). If the logic in \gls{pl} becomes corrupted due to a bit flip, for instance, in the AXI interface registers, finite state machines, or control logic of the reconfigurable region—the \texttt{ready} or \texttt{valid} signals may get stuck in an asserted or deasserted state. Since the \gls{axi} protocol does not implement any form of timeout, when the downstream device fails to complete the transaction, the ARM processor waits indefinitely for a response, effectively freezing the execution of the software.

It is important to note that this type of failure cannot be resolved by scrubbing. When the valid or ready signal is not properly asserted toward the \gls{ps}, it becomes necessary to either re-establish these signals or reset the processor, allowing the \gls{axi} bus to restart all transactions from the beginning. A practical mitigation for this issue is the inclusion of a watchdog timer that automatically resets the processor in the event of a stall.

\begin{table}[H]
\centering
\caption{Summary of configuration bits associated with the multiplier region and the critical upsets detected during the initial \acrlong{fi} campaign.}
\label{tab:math_fi1_summary}
\begin{tabular}{l r}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Total \gls{fpga} bits (\gls{cram}) & 25,697,632 \\
Total essential bits in the multiplier region & 70,182 \\
Total injected bits & 37,809 \\
Critical bits detected: Multiplication error & 7 \\
Critical bits detected: AXI bus lock & 16,000 \\
\bottomrule
\end{tabular}
\end{table}

To overcome this limitation, the automated script was updated so that whenever \gls{dut} stopped responding, the processor was reset and \gls{fpga} was fully reprogrammed. This modification allowed the experiments to continue without manual intervention and resulted in more stable executions, resulting in only three configuration frames causing this type of critical failure that led the ARM processor to stall.

Table~\ref{tab:math_fi2_summary} presents the results obtained with the updated script, in which all essential bits within the \gls{pr} regions were successfully tested against bit flips. The table also summarizes the error statistics and the occurrences of \gls{axi} bus stalls.

Figure~\ref{fig:mult-list-reprogram} shows the completion of the \gls{fi} campaign for all essential bits in the \gls{pr} region, applying reprogramming whenever a \gls{ps} stall was detected.

\begin{table}[H]
\centering
\caption{Summary of configuration bits associated with the multiplier region and the critical upsets detected during the \acrlong{fi} campaign with \acrshort{ps} stall detection.}
\label{tab:math_fi2_summary}
\begin{tabular}{l r}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Total \gls{fpga} bits (\gls{cram}) & 25,697,632 \\
Total essential bits in the multiplier region & 70,182 \\
Total injected bits & 70,182 \\
Critical bits detected: Multiplication error & 29 \\
Critical bits detected: AXI bus lock & 3 \\
\bottomrule
\end{tabular}
\end{table}

As shown in Table~\ref{tab:math_fi2_summary}, all injected faults were single-bit flips, and since \gls{semip} operates with a \gls{secded} \gls{ecc}, all 29 critical bits that caused errors in multiplication performed by \gls{hw} were successfully corrected by scrubbing. However, the three critical bits that caused the \gls{axi} bus to lock were only corrected after resetting \gls{ps} and performing a full reprogramming of \gls{fpga}.

Using Equation~\ref{eq:failure_sensitivity}, the failure sensitivity \( r \) obtained for this second experiment is approximately \( 0.41 \times 10^{-3} \) for multiplication error and \( 0.043 \times 10^{-3} \) for \gls{axi} stall.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{Cap5/mult/mult_injection_results-wo_reprogram.png}
    \caption{Automated \acrlong{fi} results obtained without the reprogramming capability.}
    \label{fig:mult-list-wo-reprogram}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{Cap5/mult/mult-error-reprogram.png}
    \caption{Automated \acrlong{fi} results obtained with the reprogramming capability enabled.}
    \label{fig:mult-list-reprogram}
\end{figure}

Figure~\ref{fig:mult-list-reprogram} shows only a subset of the addresses that caused faults. For the complete list of all addresses that produced errors during this \gls{fi} campaign, refer to \hyperref[apeB:mult-list-w-axi-error]{Appendix~B — Multiplication SEU AXI Error (ARM Stall) List} and \hyperref[apeB:mult-list-w-error]{Appendix~B — Multiplication SEU Error List}.

The \gls{ms} based on the \gls{semip} demonstrates high efficiency, providing substantial fault-mitigation benefits with a logic utilization below 2\% of the total \gls{fpga} resources, as detailed in Appendix~\ref{apeC}.

\section{RISC-V with Triple Modular Redundancy}

Continuing the evaluation of \gls{nmr}, the \gls{dmr} configuration was extended to a \gls{tmr} scheme. For this purpose, a different \gls{dut} was selected: the \gls{riscv} processor. The chosen implementation of the \gls{cpu} was the open-source PicoRV32I core.

Table~\ref{tab:tmr_resource_comparison} presents the resource utilization results comparing the simplex and \gls{tmr} implementations of the PicoRV32I \gls{cpu}. The triplication of the processor and inclusion of word voters resulted in increased resource consumption relative to the baseline design. Synthesis performed in Vivado~2018.3 reported a 3.09$\times$ increase in Slice LUT usage and a 3.35$\times$ increase in Slice Flip-Flops.

\begin{table}[H]
\centering
\caption{Resource utilization comparison between simplex and \gls{tmr} implementations of the PicoRV32I \gls{cpu}.}
\label{tab:tmr_resource_comparison}
\begin{adjustbox}{max width=\textwidth}
\begin{tabular}{lccc}
\hline
\textbf{Resource} & \textbf{Simplex (1 Core)} & \textbf{\gls{tmr} (3 Cores)} & \textbf{Increase Ratio} \\
\hline
Slice LUTs & 887 & 2,737 & 3.09 \\
Slice Flip-Flops (FFs) & 517 & 1,731 & 3.35 \\
\hline
\end{tabular}
\end{adjustbox}
\end{table}

\subsection{Simulated Fault Injection}

In this case, the \gls{fi} method was performed through simulation using the mutant-based approach. This method was selected to evaluate the fault injection time and to compare the results with those obtained from hardware-based emulation.

Figure~\ref{fig:risc-simul-hw-console} shows the simulation results of the \gls{dut}. The console output displays the greeting message generated by a simple C-written firmware, executed by each \gls{cpu} core. The message output is word-voted, and since this is a \gls{tmr} implementation, the system can mask a fault in up to one of the modules.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{Cap5/rv_simul/simulation_result_hello_world.png}
    \caption{Self-check simulation setup in which the processor cores execute test firmware transmitting the message “Hello World” through the serial output interface.}
    \label{fig:risc-simul-hw-console}
\end{figure}

% ===========================
% No Fault Case
% ===========================
Figure~\ref{fig:no-riscv-fault} illustrates the state of the simulation without injection of faults. In this scenario, all three cores execute the same firmware, producing identical outputs. The voter therefore outputs the correct value, and no fault condition is observed.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/rv_simul/all_modules_ok.png}
    \caption{Fault-free operation of the \acrshort{tmr}-protected PicoRV32I processor, showing memory write data signals and corresponding serial output during normal execution.}
    \label{fig:no-riscv-fault}
\end{figure}

% ===========================
% Single Fault Case
% ===========================
Figure~\ref{fig:1-riscv-fault} presents the case where a single bit flip was injected into core~1. Even though one core produces an incorrect result, the majority voter successfully masks the fault, and the overall system output remains correct. The serial interface output and memory write signals confirm proper operation, demonstrating the effectiveness of the \gls{tmr} scheme in tolerating single faults.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/rv_simul/1_module_fault.png}
    \caption{Single fault case showing a bit flip injected in core 1 (A input). Despite the injected error, the serial interface output and memory write signals remain correct due to fault masking by the word voter (signal OUT).}
    \label{fig:1-riscv-fault}
\end{figure}

% ===========================
% Double Fault Case
% ===========================
Figure~\ref{fig:2-riscv-fault} shows the scenario in which two cores experience the same injected error. In this case, the voted output becomes incorrect, preventing the system from booting properly and generating the expected “Hello World” message. This shows that when more than one module is affected simultaneously, the \gls{tmr} architecture cannot maintain functional correctness.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/rv_simul/2_modules_equl_fault.png}
    \caption{Double fault scenario: two cores experience the same injected error. The voted output becomes incorrect, preventing the system from booting and displaying the “Hello World” message.}
    \label{fig:2-riscv-fault}
\end{figure}

% ===========================
% Multiple Fault Case
% ===========================
Finally, Figure~\ref{fig:3-riscv-fault} represents the multiple-fault condition, where all three processor cores exhibit different faulty outputs. As a result, no valid majority can be established, and the ERROR signal is asserted, indicating a complete divergence among the redundant modules.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/rv_simul/3_modules_diff_faults.png}
    \caption{Multiple fault scenario: all cores are affected, preventing a valid majority vote. The ERROR signal indicates divergence among the three modules.}
    \label{fig:3-riscv-fault}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%IMPACT
\section{Impact of Mitigation Techniques}
\label{sec:impact-mitigation}

This section discusses the general impact of the mitigation strategies implemented in this study, including \gls{nmr}, \gls{ms}, and \gls{dpr}. The results obtained are compared with the unprotected baseline designs, highlighting measurable improvements in reliability, fault coverage, and recovery time, as well as the associated resource trade-offs.

\subsection{Fault Coverage and Failure Sensitivity}

The results obtained from the \gls{fir} and math function tests clearly demonstrate that fault coverage is strongly influenced by the adopted mitigation mechanisms. In the unprotected \gls{fir} design, the first failure occurred after only 50 bit flips during random fault injection in \gls{cram}. Since \gls{semip} operating under \gls{secded} \gls{ecc} can correct only one error per frame, the accumulation of multi-bit upsets (\glspl{mbu}) caused the system to collapse after 3,564 injections, rendering even the serial interface inoperative. The corresponding failure sensitivity, computed as \(r = k/n\), reached approximately \(r = 0.98\), indicating that nearly every injected fault at this stage produced an observable malfunction.

When scrubbing was enabled and coupled with redundancy, the results improved significantly. All single-bit upsets were transparently corrected by the \gls{semip}, and the \gls{fir} continued to operate seamlessly. This confirms that the combination of internal scrubbing and design-level redundancy provides efficient protection against transient \glspl{seu}, substantially reducing the effective failure rate.

\subsubsection{Fault Coverage Evaluation}

The fault coverage (\(FC\)) quantifies the fraction of injected faults that were successfully masked, corrected, or recovered by the implemented mitigation strategies. It is defined by Equation~\ref{eq:fault_coverage}:

\begin{equation}
FC = 1 - \frac{k}{n}
\label{eq:fault_coverage}
\end{equation}

where \(k\) represents the number of injected faults that caused functional failures and \(n\) is the total number of injected faults during the campaign.

Table~\ref{tab:fault_coverage_summary} summarizes the calculated fault coverage for each evaluated design and mitigation level.

\begin{table}[H]
\centering
\caption{Summary of fault coverage obtained for different designs and mitigation strategies.}
\label{tab:fault_coverage_summary}
\begin{adjustbox}{max width=\textwidth}
\begin{tabular}{l r r r}
\toprule
\textbf{Design / Mitigation Level} & \textbf{Total Injections ($n$)} & \textbf{Failures ($k$)} & \textbf{Fault Coverage (\%)} \\
\midrule
\gls{fir} (no scrubbing, MBU)       & 3,615   & 3,564   & 1.4   \\
\gls{fir} (\gls{semip} scrubbing)   & 31,020  & 34      & 99.9  \\
Multiplier (initial)                & 37,809  & 16,007  & 57.7  \\
Multiplier (with recovery)          & 70,182  & 32      & 99.95 \\
\bottomrule
\end{tabular}
\end{adjustbox}
\end{table}

As shown in Table~\ref{tab:fault_coverage_summary}, fault coverage increased from only 1.4\% in the unprotected design to 99.9\% when internal scrubbing was enabled. The combination of scrubbing, processor reset, and reprogramming achieved a near-complete recovery rate of 99.95\%, confirming the effectiveness of the proposed multi-layered mitigation strategy in enhancing \gls{sram}-based \gls{fpga} reliability.

\subsection{Error Recovery and System Availability}

The addition of \gls{dpr} extended the fault-tolerance capability of the system by enabling localized recovery of defective modules. The experimental results in Section~\ref{sec:cap5} showed that each partial bitstream represented only 2.8\% of the full configuration file, allowing reconfiguration to be performed more than an order of magnitude faster than full device reprogramming. As a result, even in cases of unrecoverable upsets, only the affected region was reconfigured, keeping the static portion of the design operational. This characteristic is crucial for mission-critical systems where up-time and continuity are required.

The integration of automated \gls{fi} with recovery mechanisms also proved effective in identifying unrecoverable failures in the \gls{axi} interconnect. After the implementation of processor reset and full reprogramming logic, the number of unrecoverable stalls dropped from 16,000 to just 3 out of 70,182 injected faults—corresponding to a two-order-of-magnitude improvement in fault recovery efficiency. The updated campaign achieved a failure sensitivity of \( r \approx 0.41 \times 10^{-3} \) for regular computational errors and \( r \approx 0.043 \times 10^{-3} \) for \gls{axi} stalls.

\subsection{Redundancy and Fault Masking Effectiveness}

In the \gls{tmr}-protected PicoRV32I processor, simulated fault injection demonstrated the expected masking behavior. With a single faulty core, the system maintained correct outputs due to the majority voting logic. When two cores were affected simultaneously, the output diverged, and the system failed to boot—validating the \gls{tmr} assumption that it can tolerate only one simultaneous error. Under triple faults, the majority voter detected full disagreement, asserting the error signal. 

The implementation of \gls{tmr} increased the logic resource usage by approximately 3.1$\times$ in LUTs and 3.3$\times$ in flip-flops, consistent with theoretical expectations. However, this overhead was justified by the considerable improvement in reliability and error detection coverage. The inclusion of word-level voters instead of bitwise voters also enhanced error observability by exposing multi-module inconsistencies that would otherwise remain masked.

\subsection{Reliability Gains and Trade-offs}

Overall, the combination of \gls{dpr}, \gls{semip}-based scrubbing, and \gls{tmr} achieved a comprehensive balance between reliability and resource overhead. Each mitigation layer addressed a specific reliability dimension:
\begin{itemize}
    \item \textbf{Scrubbing} ensured automatic correction of transient single-bit faults in the configuration memory.
    \item \textbf{Redundancy} masked transient faults at the functional level, improving system-level fault coverage.
    \item \textbf{Dynamic Partial Reconfiguration} provided fast recovery from permanent or multi-bit faults while maintaining uninterrupted system operation.
\end{itemize}

Quantitatively, the adoption of these techniques reduced the system failure rate by over two orders of magnitude compared to unprotected configurations. Although this came at the cost of a threefold increase in resource utilization and a moderate increase in power consumption, the trade-off is acceptable for aerospace and mission-critical applications, where reliability and maintainability outweigh area constraints.

\subsection{Summary of Mitigation Impact}

In summary, the proposed architecture effectively demonstrated that:
\begin{itemize}
    \item Fault coverage increased from less than 10\% in unprotected designs to over 99\% when scrubbing and redundancy were combined.
    \item The \gls{mttr} improved significantly with \gls{dpr}, allowing rapid reconfiguration of faulty regions.
    \item The failure sensitivity metric decreased by more than three orders of magnitude between unprotected and protected configurations.
\end{itemize}

These results confirm that an integrated mitigation strategy combining redundancy, internal scrubbing, and partial reconfiguration is a powerful approach to enhancing \gls{sram}-based \glspl{fpga} reliability for space and high-radiation environments.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%IMPACT


% \section{Comparative Analysis with Existing Approaches}
% This section compares the proposed solution to similar works in the literature. A summary table highlights differences in methodology, fault coverage, resource overhead, and performance impact.

\section{Discussion of Findings}
The key findings are synthesized and interpreted in terms of their practical implications. The trade-offs between reliability, performance, and resource consumption are critically assessed, providing valuable insight for future improvements.

An important finding of this study was the detection of \gls{ps}--\gls{axi} bus stalls during fault emulation, which highlights one of the major advantages of performing \gls{fi} directly on real \gls{fpga} hardware. This type of failure, which arises from complex interactions between the \gls{ps} and \gls{pl}, cannot be accurately captured through traditional \gls{hdl}-only simulations. Instead, such events would require co-simulation between the ARM processor and the \gls{hdl} design, a process that is both computationally expensive and time-consuming.

Nevertheless, simulation remains an indispensable tool during the early design phase. For example, the \gls{riscv} \gls{tmr} evaluation in this work required approximately 8~minutes for each synthesis–implementation–simulation loop, with each run consuming about 1~minute of host computation to simulate only 125~$\mu$s of \gls{fpga} time. Given that the average emulation-based \gls{fi} rate achieved in this study was about six faults per second, it is evident that simulation-based injections are several orders of magnitude slower than hardware emulation using the \gls{semip}. As noted by \textcite{Garcia2020}, this makes large-scale fault campaigns impractical as design complexity increases.

As discussed by \textcite{Fibichi2019}, \gls{fi} systems that interface through slower serial communication links—such as the USB-to-serial converter employed in this research—are constrained by latency introduced by both software and hardware communication layers. The minimum achievable duration of a fault-injection sequence reported by \textcite{Fibichi2019} is 20~ms. In comparison, the average bit-flip rate achieved in this work was approximately 5.4~bit flips per second.

As presented by \textcite{Leon2024_VeeR_EH1_SEU}, their proposed hardware-injection system operates at approximately 0.2~s per injection on a single test-board, with full parallelization possible by adding more boards—comparable to the performance achieved in this work. Similarly, \textcite{Garcia2020} reported an average rate of 3~bit flips per second, nearly half the throughput demonstrated here. In another study, \textcite{Aranda2019} performed a 20-hour \gls{fi} campaign to inject 9,405~faults, whereas the proposed setup in this work can inject approximately 18,000~bit flips per hour, demonstrating a substantial improvement in injection efficiency.

% \section{Limitations}