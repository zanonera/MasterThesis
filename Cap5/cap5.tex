%\section{Results and Analysis}
\label{sec:cap5}

This chapter presents the experimental results obtained from the proposed methodology and analyzes their significance. The discussion includes performance evaluation, \gls{fi} results, comparison with reference approaches, and an assessment of the reliability improvements achieved.

\section{Experimental Setup}

The software and hardware environments used in this research are described in \hyperref[sec:cap4-material]{Section~\ref*{sec:cap4-material} -- \textit{FPGA Platform and Toolchain}}. 
Figure~\ref{fig:setup-diagram} presents the connection diagram of the experimental setup used to conduct the tests, while Figure~\ref{fig:setup-pic} shows the actual laboratory configuration adopted during this work. 
The \href{https://ftdichip.com/products/ft2232hq/}{FT2232 communication module} was connected to the \href{https://pynq.readthedocs.io/en/v2.6.1/pynq_libraries/pmod.html}{\gls{pmod}} interface of the \href{https://www.amd.com/en/corporate/university-program/aup-boards/pynq-z2.html}{PYNQ-Z2} board, providing a dual-channel USB-to-serial bridge between the host computer and the \gls{fpga} system.


\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/setup-diagram.png}
    \caption{Interconnection diagram of the main board and the USB-to-Serial interface module.}
    \label{fig:setup-diagram}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{Cap5/setup.jpg}
    \caption{Experimental setup showing the main board (center) and the USB-to-Serial interface module (upper right).}
    \label{fig:setup-pic}
\end{figure}

For a detailed explanation of this experimental setup, see \hyperref[sec:ref-design-arch]{Section 4 - Reference Design Architecture}, \hyperref[sec:fi-strategy]{Section 4 - Fault Injection Strategy} and particularly Figure~\ref{zynq-paper-arch} for a detailed block diagram of the implemented design.

% \section{Baseline Performance Evaluation}
% Before introducing fault-tolerance mechanisms, the system performance is evaluated under normal conditions. This subsection discusses metrics such as resource utilization, operating frequency, and execution latency to establish a baseline reference.

\section{Partial Reconfiguration Results}

This section discusses the \gls{dpr} results, mainly in the reprogramming speed and size of partial bitstreams.

\begin{table}[H]
\centering
\caption{Summary of \acrlong{pr} throughput and configuration time with different \acrshort{dma} settings}
\label{tab:pr_time}
\begin{tabular}{cccc}
\toprule
\textbf{Condition} & \textbf{Time ($\mu$s)} & \textbf{Throughput (Mb/s)} & \textbf{Cache} \\
\midrule
First \gls{dpr} & 897 & 143 & Enabled \\
All others \gls{dpr} & 1.35 & 95195 & Enabled \\
First \gls{dpr} & 1186 & 108 & Enabled and invalidated \\
All others \gls{dpr} & 576 & 222 & Enabled and invalidated \\
First \gls{dpr} & 984 & 130 & Disabled \\
All others \gls{dpr} & 6 & 21117 & Disabled \\
\bottomrule
\end{tabular}
\end{table}

\textcite{Sultana2021} reports that the theoretical throughput of the \gls{pcap} interface is 400~Mb/s when operating on a 32-bit platform, achieving an average throughput of approximately 140~Mb/s. This result is closely aligned with the performance observed for the first \gls{dpr} in this study, as shown in Table~\ref{tab:pr_time}.

According to the results in Table~\ref{tab:pr_time}, during the first \gls{pr}, the achieved throughput approaches the theoretical value. However, from the second reconfiguration onward, certain configurations exhibit unrealistically high speeds. This behavior was identified as a side effect of the small bitstream size used for \gls{pr} and the \gls{ddr} cache present on the Zynq device. When the cache is enabled, write speeds of up to 96~Gb/s can be observed. However, if the cache is explicitly invalidated before each \gls{pr} operation, the throughput stabilizes near the average value and remains below the theoretical limit.

This phenomenon occurs because \gls{pcap} is designed to operate via \gls{dma} transfers from Zynq's \gls{ddr} memory, thus utilizing the cache unless it is explicitly disabled or invalidated.
Higher reconfiguration speeds could potentially be achieved using custom reconfiguration controllers, as demonstrated by ~\textcite{Vipin2014_ZyCAP} on Zynq devices.

For comparison, the total size of the full bitstream is 3.9~Mbit, while each partial bitstream corresponding to the math block is 109~kbit, representing around only 2.8\% of the full configuration size. This significant reduction in bitstream size directly impacts the reconfiguration time, allowing partial reconfiguration to be performed considerably faster than a full device reconfiguration.

Figure~\ref{fig:menu-blank&dpr-error}(a) shows the time required for the first \gls{dpr} and the application of the blank bitstream. The blanking configuration corresponds to a partial bitstream that contains no logic, serving only as a placeholder to ensure a clean reprogramming of the device. Figure~\ref{fig:menu-blank&dpr-error}(b) illustrates the error that occurs when applying \gls{dpr} without resetting \gls{semip} after a \gls{pr} has been executed. This behavior is discussed in detail in Section~\ref{sec:cap4}, particularly in Item~\ref{itemized-actions-for-dpr&sem}.

\begin{figure}[H]
    \centering
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/menu-blank.png}} 
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/menu-dpr-error.png}}
    \caption{(a) Menu selection for the \acrshort{pr} of the blanking bitstream. (b) Menu indication showing that the \acrshort{pr} failed to load a new bitstream.}
    \label{fig:menu-blank&dpr-error}
\end{figure}

Figure~\ref{fig:menu-mult&mult-ok}(a) shows the \gls{pr} of the \gls{hw} acceleration region as a multiplier using \gls{dpr}. This shows that the \gls{pr} process does not affect other areas of the \gls{fpga}, allowing the system to continue to operate normally. Figure~\ref{fig:menu-mult&mult-ok}(b) presents the correct results obtained from both multiplications, in \gls{hw} and \gls{sw}.

\begin{figure}[H]
    \centering
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/menu-mult.png}} 
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/mult-ok.png}}
    \caption{(a) Menu selection of the multiplier to be applied to the \acrshort{pr}. (b) Multiplication result verification on \acrshort{hw} and \acrshort{sw}.}
    \label{fig:menu-mult&mult-ok}
\end{figure}

Figure~\ref{fig:menu-mult-error-fi}(a) shows that the multiplication, executed on \gls{hw}, produces completely incorrect results due to a \gls{fi} targeting a critical bit in frame \texttt{C0003C440C}. It is evident that the output differs from the corresponding \gls{sw} operation and does not match the expected result based on the input operands. Figure~\ref{fig:menu-mult-error-fi}(b) presents another example using different operands, demonstrating that although the output values vary, they remain incorrect.

\begin{figure}[H]
    \centering
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/mult-error.png}} 
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/mult-error2.png}}
    \caption{(a) \acrshort{hw} multiplication error after the injection of a bit flip in frame C0003C440C. (b) Multiplication results obtained with different operands.}
    \label{fig:menu-mult-error-fi}
\end{figure}

Figure~\ref{fig:menu-add&add-ok}(a) shows the \gls{pr} of the \gls{hw} acceleration region into an adder using the \gls{dpr}. This shows that the \gls{pr} process does not affect other areas of the \gls{fpga}, allowing the system to continue to operate normally. Figure~\ref{fig:menu-add&add-ok}(b) presents the correct results obtained from both additions, in \gls{hw} and \gls{sw}.

\begin{figure}[H]
    \centering
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/menu-add.png}} 
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/add-ok.png}}
    \caption{(a) Menu selection of the adder to be applied through the \acrshort{pr}. (b) Addition result verification on \acrshort{hw} and \acrshort{sw}.}
    \label{fig:menu-add&add-ok}
\end{figure}

Figure~\ref{fig:add-error-fi}(a) shows that the addition, executed on \gls{hw},  produces completely incorrect results due to a \gls{fi} targeting a critical bit in frame \texttt{C0003C440C}. It is evident that the output differs from the corresponding \gls{sw} operation and does not match the expected result based on the input operands. Figure~\ref{fig:add-error-fi}(b) presents another example using different operands, demonstrating that although the output values vary, they remain incorrect.

\begin{figure}[H]
    \centering
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/error_add_after_injection_C0003C440C.png}} 
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/add_error_other_operand.png}}
    \caption{(a) \acrshort{hw} addition error after the injection of a bit flip in frame C0003C440C. (b) Addition results obtained with different operands.}
    \label{fig:add-error-fi}
\end{figure}

\section{Fault-Injection Campaign Results}
This section presents the results of the systematic fault-injection experiments. The effects of single-event upsets (SEUs) on configuration memory and logic are analyzed, highlighting error rates, propagation patterns, and observed system-level failures.

\subsection{Scrubbing and Fault Injection with a FIR Filter}

The first design done to test the \gls{fi} and the memory scrubbing, using the \gls{semip} was with a \gls{dmr} design, where the replicated modules were two \gls{fir} filters.

The idea of using \gls{fir} filters is because they are pure mathematical modules and therefore do not need any kind of reset or resynchronization after a \gls{fi} and a repair 

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/dut_fir/automated_design.png}
    \caption{Representation of the complete automation of the \acrlong{fi} process and the use of the \acrshort{ila} for real-time visualization and debugging of the design behavior during fault injection.}
    \label{fig:automated_design}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/dut_fir/error-injection.png}
    \caption{Python script and corresponding visualization showing the real-time progress of the \acrshort{fi} campaign}
    \label{fig:error-injection-fir}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/dut_fir/fir_filter_equal.png}
    \caption{\acrshort{ila} waveform capture demonstrating the correct functionality of both filter modules, confirming synchronized operation and expected output behavior.}
    \label{fig:fir_filter_equal}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/dut_fir/error-fir-filter.png}
    \caption{\acrshort{ila} waveform capture illustrating a \acrshort{fi} event that resulted in an erroneous output from the \acrshort{fir} filter, evidencing the effect of a configuration bit upset on functional behavior.}
    \label{fig:fir_filter_error}
\end{figure}

The proposed injection system also presents some limitations compared to other approaches. Running at about 0.2 s per injection in a single test-board environment (fully parallel execution is possible by adding more boards), it is slower than non fine-grain software simulators, such as GEM5 [32], virtual platforms like SOFIA [34] and, potentially, RTL-modified based testing [22] on \gls{fpga}. However, equivalent state-of-the-art fine-grain software RTL simulators run at as low as 1 KHz on modern CPUs [49,50] making simulation at this granularity much slower than the proposed one \cite{Leon2024_VeeR_EH1_SEU}.

\begin{table}[H]
\centering
\caption{Summary of configuration bits associated with the \acrshort{fir} region and the critical upsets detected during the \acrlong{fi} campaign.}
\label{tab:fir_fi_summary}
\begin{tabular}{l r}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Total \gls{fpga} bits (\gls{cram}) & 25,697,632 \\
Total essential bits in the \gls{fir} region & 31,020 \\
Total injected bits & 31,020 \\
Critical bits detected: \gls{fir} error & 34 \\
Critical bits detected: AXI bus lock & \gls{na} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{DPR, Scrubbing and Fault Injection with Mathematical Functions}

After the successful implementation of scrubbing using \gls{semip} with \gls{dmr} \gls{fir} filters, the next design iteration incorporated \gls{dpr} into the system functionalities. To fully exploit the resources of \gls{soc}, a \gls{axi} controlled multiplier/adder module was developed. These hardware functions can be selected via a user menu and dynamically reconfigured within \gls{fpga}.

The same automated \gls{fi} campaign was applied; however, during the first attempt, it was not possible to inject faults into all essential bits of the \gls{pr} region, as some injections caused the \gls{ps} ARM processor to stall.

After 21,809 fault injections, the automated script stopped receiving responses from the \gls{dut}. Since the device ceased sending status feedback, the script was manually terminated.

Figure~\ref{fig:mult-list-wo-reprogram} presents the output of the statistical report script, showing 16,000 configuration frames affected by bit flips that caused the \gls{dut} to stop responding.

Initially, all these faults were assumed to correspond to a critical failure that stopped communication with the \gls{dut}. However, a detailed analysis revealed that a bit flip in the \gls{fpga} \gls{cram} corrupted the \gls{axi} bus, leading to a processor stall. The results of this first \gls{fi} campaign are summarized in Table~\ref{tab:math_fi1_summary}.

Once one of the injected frames caused the ARM processor to stall, all subsequent fault injections were affected, as the \gls{axi} bus stopped working, preventing  further communication with \gls{dut}.

The processor stalls is caused by the \gls{axi} bus, which operates based on a strict valid/ready signal's handshake between the master (e.g., ARM \gls{ps}) and the slave (e.g., the custom \gls{dpr} \gls{ip} core in the \gls{pl}). If the logic in \gls{pl} becomes corrupted due to a bit flip—for instance, in the AXI interface registers, finite state machines, or control logic of the reconfigurable region—the \texttt{ready} or \texttt{valid} signals may get stuck in an asserted or deasserted state. Since the \gls{axi} protocol does not implement any form of timeout, when the downstream device fails to complete the transaction, the ARM processor waits indefinitely for a response, effectively freezing the execution of the software.

It is important to note that this type of failure cannot be resolved by scrubbing. When the valid or ready signal is not properly asserted toward the \gls{ps}, it becomes necessary to either re-establish these signals or reset the processor, allowing the \gls{axi} bus to restart all transactions from the beginning. A practical mitigation for this issue is the inclusion of a watchdog timer that automatically resets the processor in the event of a stall.

\begin{table}[H]
\centering
\caption{Summary of configuration bits associated with the multiplier region and the critical upsets detected during the initial \acrlong{fi} campaign.}
\label{tab:math_fi1_summary}
\begin{tabular}{l r}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Total \gls{fpga} bits (\gls{cram}) & 25,697,632 \\
Total essential bits in the multiplier region & 70,182 \\
Total injected bits & 37,809 \\
Critical bits detected: Multiplication error & 7 \\
Critical bits detected: AXI bus lock & 16,000 \\
\bottomrule
\end{tabular}
\end{table}

To overcome this limitation, the automated script was updated so that whenever \gls{dut} stopped responding, the processor was reset and \gls{fpga} was fully reprogrammed. This modification allowed the experiments to continue without manual intervention and resulted in more stable executions, resulting in only three configuration frames causing this type of critical failure that led the ARM processor to stall.

Table~\ref{tab:math_fi2_summary} presents the results obtained with the updated script, in which all essential bits within the \gls{pr} regions were successfully tested against bit flips. The table also summarizes the error statistics and the occurrences of \gls{axi} bus stalls.

Figure~\ref{fig:mult-list-reprogram} shows the completion of the \gls{fi} campaign for all essential bits in the \gls{pr} region, applying reprogramming whenever a \gls{ps} stall was detected.

\begin{table}[H]
\centering
\caption{Summary of configuration bits associated with the multiplier region and the critical upsets detected during the \acrlong{fi} campaign with \acrshort{ps} stall detection.}
\label{tab:math_fi2_summary}
\begin{tabular}{l r}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Total \gls{fpga} bits (\gls{cram}) & 25,697,632 \\
Total essential bits in the multiplier region & 70,182 \\
Total injected bits & 70,182 \\
Critical bits detected: Multiplication error & 29 \\
Critical bits detected: AXI bus lock & 3 \\
\bottomrule
\end{tabular}
\end{table}

As shown in Table~\ref{tab:math_fi2_summary}, all injected faults were single-bit flips, and since the \gls{semip} operates with a \gls{secded} \gls{ecc}, all 29 critical bits that caused errors in the multiplication performed by the \gls{hw} were successfully corrected by scrubbing. However, the three critical bits that caused the \gls{axi} bus to lock were only corrected after resetting the \gls{ps} and performing a full reprogramming of the \gls{fpga}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{Cap5/mult/mult_injection_results-wo_reprogram.png}
    \caption{Automated \acrlong{fi} results obtained without the reprogramming capability.}
    \label{fig:mult-list-wo-reprogram}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{Cap5/mult/mult-error-reprogram.png}
    \caption{Automated \acrlong{fi} results obtained with the reprogramming capability enabled.}
    \label{fig:mult-list-reprogram}
\end{figure}

Figure~\ref{fig:mult-list-reprogram} shows only a subset of the addresses that caused faults. For the complete list of all addresses that produced errors during this \gls{fi} campaign, refer to \hyperref[apeB:mult-list-w-axi-error]{Appendix~B — Multiplication SEU AXI Error (ARM Stall) List} and \hyperref[apeB:mult-list-w-error]{Appendix~B — Multiplication SEU Error List}.

\section{RISC-V with Triple Modular Redundancy}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{Cap5/rv_simul/simulation_result_hello_world.png}
    \caption{Self-check simulation setup in which the processor cores execute test firmware transmitting the message “Hello World” through the serial output interface.}
    \label{fig:risc-simul-hw-console}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/rv_simul/all_modules_ok.png}
    \caption{Fault-free operation of the \acrshort{tmr}-protected PicoRV32I processor, showing memory write data signals and corresponding serial output during normal execution.}
    \label{fig:no-riscv-fault}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/rv_simul/1_module_fault.png}
    \caption{Single fault case showing a bit flip injected in core 1 (A input). Despite the injected error, the serial interface output and memory write signals remain correct due to fault masking by the word voter (signal OUT).}
    \label{fig:1-riscv-fault}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/rv_simul/2_modules_equl_fault.png}
    \caption{Double fault scenario: two cores experience the same injected error. The voted output becomes incorrect, preventing the system from booting and displaying the “Hello World” message.}
    \label{fig:2-riscv-fault}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/rv_simul/3_modules_diff_faults.png}
    \caption{Multiple fault scenario: all cores are affected, preventing a valid majority vote. The ERROR signal indicates divergence among the three modules.}
    \label{fig:3-riscv-fault}
\end{figure}

\section{Impact of Mitigation Techniques}
The results obtained after implementing the proposed fault-mitigation strategies are discussed. Comparisons are made between unprotected and protected designs, focusing on improvements in fault coverage, error recovery, and reliability metrics.

\section{Comparative Analysis with Existing Approaches}
This section compares the proposed solution to similar works in the literature. A summary table highlights differences in methodology, fault coverage, resource overhead, and performance impact.

\section{Discussion of Findings}
The key findings are synthesized and interpreted in terms of practical implications. The trade-offs between reliability, performance, and resource consumption are critically assessed, providing information for future improvements.

As discussed in \textcite{Fibichi2019}, \gls{fi} systems that interface through slower serial communication links, such as the USB-to-serial converter used in this research, are constrained by the latency introduced by the software and hardware communication stack. The minimum achievable duration of the fault injection sequence achieved by \textcite{Fibichi2019} is reported to be 20 milliseconds. The average speed achieved by this research is 6 bit flip per second.

The finding of the \gls{ps} \gls{axi} bus stall during the \gls{fi} shows the biggest advantage of this kind of test using the physical \gls{fpga} device under bit flips.

This kind off error, as it needs a large interaction between the \gls{ps} and \gls{pl}, it is not possible to simply simulate the \gls{hdl} design, it needs a co-simulation between the ARM processor and the \gls{hdl}. This type of co-simulation is complex and very time consuming.

Simulation is an indispensable tool during the design phase, as presented in the results of \gls{riscv} with \gls{tmr}. This work presented a time of 8 minutes for each loop of synthesis, implementation, and simulation. Each simulation loop took 16s of computer time to run only 125$\mu$s of \gls{fpga} time.