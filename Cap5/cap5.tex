%\section{Results and Analysis}
\label{sec:cap5}

This chapter presents the experimental results obtained from the proposed methodology and analyzes their significance. The discussion includes performance evaluation, fault-injection results, comparison with reference approaches, and an assessment of the reliability improvements achieved.

\section{Experimental Setup}

The software and hardware used in this research is discussed in \hyperref[sec:cap4-material]{Section 4 - FPGA Platform and Toolchain}. Figure~\ref{fig:setup-diagram} illustrates the connection diagram to conduct the research. Figure~\ref{fig:setup-pic} illustrates the setup used during this work. The \href{https://ftdichip.com/products/ft2232hq/}{FT-2232 module} is connected to the \href{https://pynq.readthedocs.io/en/v2.6.1/pynq_libraries/pmod.html}{\gls{pmod}} connector of the \href{https://www.amd.com/en/corporate/university-program/aup-boards/pynq-z2.html}{Pynq-Z2}.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/setup-diagram.png}
    \caption{Interconnection diagram of the main board and the USB to Serial Interface module.}
    \label{fig:setup-diagram}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{Cap5/setup.jpg}
    \caption{Setup of the main board (center) and the USB to Serial Interface module (up right).}
    \label{fig:setup-pic}
\end{figure}

For a detailed explanation of this experimental setup, see \hyperref[sec:ref-design-arch]{Section 4 - Reference Design Architecture}, \hyperref[sec:fi-strategy]{Section 4 - Fault Injection Strategy} and particularly Figure~\ref{zynq-paper-arch} for a detailed block diagram of the implemented design.

\section{Baseline Performance Evaluation}
Before introducing fault-tolerance mechanisms, the system performance is evaluated under normal conditions. This subsection discusses metrics such as resource utilization, operating frequency, and execution latency to establish a baseline reference.

\section{Partial Reconfiguration Results}

This section discusses the \gls{dpr} results, mainly in the reprogramming speed and size of the partial bitstreams.

\begin{table}[H]
\centering
\caption{\acrlong{pr}.}
\label{tab:pr_time}
\begin{tabular}{lccc}
\toprule
\textbf{Condition} & \textbf{Time ($\mu$s)} & \textbf{Throughput (Mb/s)} & \textbf{Cache} \\
\midrule
First \gls{dpr} & 897 & 143 & Enabled \\
All others \gls{dpr} & 1.35 & 95,195 & Enabled \\
First \gls{dpr} & 1,186 & 108 & Enabled and invalidated \\
All others \gls{dpr} & 576 & 222 & Enabled and invalidated \\
First \gls{dpr} & 984 & 130 & Disabled \\
All others \gls{dpr} & 6 & 21,117 & Disabled \\
\bottomrule
\end{tabular}
\end{table}

\begin{figure}[H]
    \centering
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/menu-blank.png}} 
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/menu-dpr-error.png}}
    \caption{(a) Menu Selection of the \acrshort{pr} of the blanking bitstream (b) Menu indication that the \acrshort{pr} failed to set a new bitstream.}
    \label{fig:menu-blank&dpr-error}
\end{figure}

\begin{figure}[H]
    \centering
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/menu-mult.png}} 
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/mult-ok.png}}
    \caption{(a) Menu Selection of the multiplier to be applied to the \acrshort{pr} (b) Multiplication check on \acrshort{hw} and \acrshort{sw}.}
    \label{fig:menu-mult&mult-ok}
\end{figure}

\begin{figure}[H]
    \centering
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/menu-add.png}} 
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/add-ok.png}}
    \caption{(a) Menu Selection of the adder to be applied to the \acrshort{pr} (b) Addition check on \acrshort{hw} and \acrshort{sw}.}
    \label{fig:menu-add&add-ok}
\end{figure}

\begin{figure}[H]
    \centering
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/error_add_after_injection_C0003C440C.png}} 
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/add_error_other_operand.png}}
    \caption{(a) \acrshort{hw} addition error after injection of an bit flip in Region \emph{C0003C440C} (b) Showing the value with other operands for the addition.}
    \label{fig:add-error-fi}
\end{figure}

\section{Fault-Injection Campaign Results}
This section presents the results of the systematic fault-injection experiments. The effects of single-event upsets (SEUs) on configuration memory and logic are analyzed, highlighting error rates, propagation patterns, and observed system-level failures.

\subsection{FIR Filter block}

\subsubsection{Scrubbing and Fault Injection with a FIR Filter}

The first design done to test the \gls{fi} and the memory scrubbing, using the \gls{semip} was with a \gls{dmr} design, where the replicated modules were two \gls{fir} filters.

The idea of using \gls{fir} filters is because they are pure mathematical modules and so they do not need any kind of reset or resynchronization after a \gls{fi} and a repair 

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Cap5/dut_fir/automated_design.png}
    \caption{Complete automation of the \acrlong{fi} and visualization of the \acrshort{ila} to "debug" the design.}
    \label{fig:automated_design}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Cap5/dut_fir/error-injection.png}
    \caption{Script and visualization of the progress of \acrshort{fi} campaign.}
    \label{fig:error-injection-fir}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Cap5/dut_fir/fir_filter_equal.png}
    \caption{\acrshort{ila} capture, showing correct function of both filters.}
    \label{fig:fir_filter_equal}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Cap5/dut_fir/error-fir-filter.png}
    \caption{\acrshort{ila} capture, showing a \acrshort{fi} that caused an error in the output of the \acrshort{fir} filter.}
    \label{fig:fir_filter_error}
\end{figure}

The proposed injection system also presents some limitations when compared to other approaches. Running at about 0.2 s per injection in a single test-board environment (fully parallel execution is possible by adding more boards), it is slower than non fine-grain software simulators, such as GEM5 [32], virtual platforms like SOFIA [34] and, potentially, RTL-modified based testing [22] on \gls{fpga}. However, equivalent state-of-the-art fine-grain software RTL simulators run at as low as 1 KHz on modern CPUs [49,50] making simulation at this granularity much slower than the proposed one \cite{Leon2024_VeeR_EH1_SEU}.

\begin{table}[H]
\centering
\caption{Summary of configuration bits and detected critical upsets in the FIR region.}
\label{tab:fir_fi_summary}
\begin{tabular}{l r}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Total \gls{fpga} bits (\gls{cram}) & 25.697.632 \\
Total essential bits in the \gls{fir} region & 31.020 \\
Total injected bits & 31.020 \\
Critical bits detected: \gls{fir} error & 34 \\
Critical bits detected: AXI bus lock & \gls{na} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Math \glsentrytext{dpr} block}

\begin{table}[H]
\centering
\caption{Summary of configuration bits and detected critical upsets in the multiplier region.}
\label{tab:math_fi_summary}
\begin{tabular}{l r}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Total \gls{fpga} bits (\gls{cram}) & 25.697.632 \\
Total essential bits in the multiplier region & 70.182 \\
Total injected bits & 70.182 \\
Critical bits detected: Multiplication error & 29 \\
Critical bits detected: AXI bus lock & 3 \\
\bottomrule
\end{tabular}
\end{table}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{Cap5/mult/mult_injection_results-wo_reprogram.png}
    \caption{Automated \acrlong{fi} result without the reprogram ability.}
    \label{fig:mult-list-wo-reprogram}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{Cap5/mult/mult-error-reprogram.png}
    \caption{Automated \acrlong{fi} result with the reprogram ability.}
    \label{fig:mult-list-reprogram}
\end{figure}

For a complete list with the addresses that caused error in this \gls{fi} campaign, consult \hyperref[apeB:mult-list-w-axi-error]{Appendix B - Multiplication SEU AXI Error (ARM stall) List} and \hyperref[apeB:mult-list-w-error]{Appendix B - Multiplication SEU Error List}.

\section{Impact of Mitigation Techniques}
The results obtained after implementing the proposed fault-mitigation strategies are discussed. Comparisons are made between unprotected and protected designs, focusing on improvements in fault coverage, error recovery, and reliability metrics.

\section{Comparative Analysis with Existing Approaches}
This section compares the proposed solution to similar works in the literature. A summary table highlights differences in methodology, fault coverage, resource overhead, and performance impact.

\section{Discussion of Findings}
The key findings are synthesized and interpreted in terms of practical implications. The trade-offs between reliability, performance, and resource consumption are critically assessed, providing information for future improvements.

As discussed in \textcite{Fibichi2019}, \gls{fi} systems that interface through slower serial communication links, such as the USB-to-serial converter used in this research, are constrained by the latency introduced by the software and hardware communication stack. The minimum achievable fault injection sequence duration achieved by \textcite{Fibichi2019} is reported to be 20 milliseconds. The reported \gls{fi} reported by is 4.6 ms.