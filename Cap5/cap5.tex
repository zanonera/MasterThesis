%\section{Results and Analysis}
\label{sec:cap5}

This chapter presents the experimental results obtained from the proposed methodology and analyzes their significance. The discussion includes performance evaluation, fault-injection results, comparison with reference approaches, and an assessment of the reliability improvements achieved.

\section{Experimental Setup}

The software and hardware used in this research is discussed in \hyperref[sec:cap4-material]{Section 4 - FPGA Platform and Toolchain}. Figure~\ref{fig:setup-diagram} illustrates the connection diagram to conduct the research. Figure~\ref{fig:setup-pic} illustrates the setup used during this work. The \href{https://ftdichip.com/products/ft2232hq/}{FT-2232 module} is connected to the \href{https://pynq.readthedocs.io/en/v2.6.1/pynq_libraries/pmod.html}{\gls{pmod}} connector of the \href{https://www.amd.com/en/corporate/university-program/aup-boards/pynq-z2.html}{Pynq-Z2}.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/setup-diagram.png}
    \caption{Interconnection diagram of the main board and the USB to Serial Interface module.}
    \label{fig:setup-diagram}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{Cap5/setup.jpg}
    \caption{Setup of the main board (center) and the USB to Serial Interface module (up right).}
    \label{fig:setup-pic}
\end{figure}

For a detailed explanation of this experimental setup, see \hyperref[sec:ref-design-arch]{Section 4 - Reference Design Architecture}, \hyperref[sec:fi-strategy]{Section 4 - Fault Injection Strategy} and particularly Figure~\ref{zynq-paper-arch} for a detailed block diagram of the implemented design.

\section{Baseline Performance Evaluation}
Before introducing fault-tolerance mechanisms, the system performance is evaluated under normal conditions. This subsection discusses metrics such as resource utilization, operating frequency, and execution latency to establish a baseline reference.

\section{Partial Reconfiguration Results}

This section discusses the \gls{dpr} results, mainly in the reprogramming speed and size of partial bitstreams.

\begin{table}[H]
\centering
\caption{\acrlong{pr}.}
\label{tab:pr_time}
\begin{tabular}{cccc}
\toprule
\textbf{Condition} & \textbf{Time ($\mu$s)} & \textbf{Throughput (Mb/s)} & \textbf{Cache} \\
\midrule
First \gls{dpr} & 897 & 143 & Enabled \\
All others \gls{dpr} & 1.35 & 95,195 & Enabled \\
First \gls{dpr} & 1,186 & 108 & Enabled and invalidated \\
All others \gls{dpr} & 576 & 222 & Enabled and invalidated \\
First \gls{dpr} & 984 & 130 & Disabled \\
All others \gls{dpr} & 6 & 21,117 & Disabled \\
\bottomrule
\end{tabular}
\end{table}

\begin{figure}[H]
    \centering
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/menu-blank.png}} 
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/menu-dpr-error.png}}
    \caption{(a) Menu Selection of the \acrshort{pr} of the blanking bitstream (b) Menu indication that the \acrshort{pr} failed to set a new bitstream.}
    \label{fig:menu-blank&dpr-error}
\end{figure}

\begin{figure}[H]
    \centering
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/menu-mult.png}} 
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/mult-ok.png}}
    \caption{(a) Menu Selection of the multiplier to be applied to the \acrshort{pr} (b) Multiplication check on \acrshort{hw} and \acrshort{sw}.}
    \label{fig:menu-mult&mult-ok}
\end{figure}

\begin{figure}[H]
    \centering
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/menu-add.png}} 
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/add-ok.png}}
    \caption{(a) Menu Selection of the adder to be applied to the \acrshort{pr} (b) Addition check on \acrshort{hw} and \acrshort{sw}.}
    \label{fig:menu-add&add-ok}
\end{figure}

\begin{figure}[H]
    \centering
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/error_add_after_injection_C0003C440C.png}} 
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/add_error_other_operand.png}}
    \caption{(a) \acrshort{hw} addition error after injection of an bit flip in Region \emph{C0003C440C} (b) Showing the value with other operands for the addition.}
    \label{fig:add-error-fi}
\end{figure}

\section{Fault-Injection Campaign Results}
This section presents the results of the systematic fault-injection experiments. The effects of single-event upsets (SEUs) on configuration memory and logic are analyzed, highlighting error rates, propagation patterns, and observed system-level failures.

\subsection{Scrubbing and Fault Injection with a FIR Filter}

The first design done to test the \gls{fi} and the memory scrubbing, using the \gls{semip} was with a \gls{dmr} design, where the replicated modules were two \gls{fir} filters.

The idea of using \gls{fir} filters is because they are pure mathematical modules and so they do not need any kind of reset or resynchronization after a \gls{fi} and a repair 

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Cap5/dut_fir/automated_design.png}
    \caption{Complete automation of the \acrlong{fi} and visualization of the \acrshort{ila} to "debug" the design.}
    \label{fig:automated_design}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Cap5/dut_fir/error-injection.png}
    \caption{Script and visualization of the progress of \acrshort{fi} campaign.}
    \label{fig:error-injection-fir}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Cap5/dut_fir/fir_filter_equal.png}
    \caption{\acrshort{ila} capture, showing correct function of both filters.}
    \label{fig:fir_filter_equal}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Cap5/dut_fir/error-fir-filter.png}
    \caption{\acrshort{ila} capture, showing a \acrshort{fi} that caused an error in the output of the \acrshort{fir} filter.}
    \label{fig:fir_filter_error}
\end{figure}

The proposed injection system also presents some limitations compared to other approaches. Running at about 0.2 s per injection in a single test-board environment (fully parallel execution is possible by adding more boards), it is slower than non fine-grain software simulators, such as GEM5 [32], virtual platforms like SOFIA [34] and, potentially, RTL-modified based testing [22] on \gls{fpga}. However, equivalent state-of-the-art fine-grain software RTL simulators run at as low as 1 KHz on modern CPUs [49,50] making simulation at this granularity much slower than the proposed one \cite{Leon2024_VeeR_EH1_SEU}.

\begin{table}[H]
\centering
\caption{Summary of configuration bits and detected critical upsets in the FIR region.}
\label{tab:fir_fi_summary}
\begin{tabular}{l r}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Total \gls{fpga} bits (\gls{cram}) & 25.697.632 \\
Total essential bits in the \gls{fir} region & 31.020 \\
Total injected bits & 31.020 \\
Critical bits detected: \gls{fir} error & 34 \\
Critical bits detected: AXI bus lock & \gls{na} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{DPR, Scrubbing and Fault Injection with Mathematical Functions}

\begin{table}[H]
\centering
\caption{Summary of configuration bits and detected critical upsets in the multiplier region.}
\label{tab:math_fi_summary}
\begin{tabular}{l r}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Total \gls{fpga} bits (\gls{cram}) & 25.697.632 \\
Total essential bits in the multiplier region & 70.182 \\
Total injected bits & 70.182 \\
Critical bits detected: Multiplication error & 29 \\
Critical bits detected: AXI bus lock & 3 \\
\bottomrule
\end{tabular}
\end{table}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{Cap5/mult/mult_injection_results-wo_reprogram.png}
    \caption{Automated \acrlong{fi} result without the reprogram ability.}
    \label{fig:mult-list-wo-reprogram}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{Cap5/mult/mult-error-reprogram.png}
    \caption{Automated \acrlong{fi} result with the reprogram ability.}
    \label{fig:mult-list-reprogram}
\end{figure}

For a complete list of the addresses that caused error in this \gls{fi} campaign, consult \hyperref[apeB:mult-list-w-axi-error]{Appendix B - Multiplication SEU AXI Error (ARM stall) List} and \hyperref[apeB:mult-list-w-error]{Appendix B - Multiplication SEU Error List}.

\section{RISC-V with Triple Modular Redundancy}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{Cap5/rv_simul/simulation_result_hello_world.png}
    \caption{Self-check simulation setup, where the processor cores execute test firmware that transmits the message ``Hello World'' through a serial output interface.}
    \label{fig:risc-simul-hw-console}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/rv_simul/all_modules_ok.png}
    \caption{Fault Free \acrshort{tmr}'ed PicoRV32I Write Data to memory signals and serial Output.}
    \label{fig:no-riscv-fault}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/rv_simul/1_module_fault.png}
    \caption{Single Fault, a bit flip in core 1 (A Input in the figure), the output of the serial interface and the memory access remains without faults after the word voter (signal OUT).}
    \label{fig:1-riscv-fault}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/rv_simul/2_modules_equl_fault.png}
    \caption{Two faulty, with the same error injected, their output is voted, but as it is incorrect, the system does not boot correctly and does not show the greeting message.}
    \label{fig:2-riscv-fault}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/rv_simul/3_modules_diff_faults.png}
    \caption{Multiple Faults, in this case all cores are faulty, so no majority is voted and then the ERROR signal shows that all three modules diverges.}
    \label{fig:3-riscv-fault}
\end{figure}

\section{Impact of Mitigation Techniques}
The results obtained after implementing the proposed fault-mitigation strategies are discussed. Comparisons are made between unprotected and protected designs, focusing on improvements in fault coverage, error recovery, and reliability metrics.

\section{Comparative Analysis with Existing Approaches}
This section compares the proposed solution to similar works in the literature. A summary table highlights differences in methodology, fault coverage, resource overhead, and performance impact.

\section{Discussion of Findings}
The key findings are synthesized and interpreted in terms of practical implications. The trade-offs between reliability, performance, and resource consumption are critically assessed, providing information for future improvements.

As discussed in \textcite{Fibichi2019}, \gls{fi} systems that interface through slower serial communication links, such as the USB-to-serial converter used in this research, are constrained by the latency introduced by the software and hardware communication stack. The minimum achievable duration of the fault injection sequence achieved by \textcite{Fibichi2019} is reported to be 20 milliseconds. The average speed achieved by this research is 6 bit flip per second.

The finding of the \gls{ps} \gls{axi} bus stall during the \gls{fi} shows the biggest advantage of this kind of test using the physical \gls{fpga} device under bit flips.

This kind off error, as it needs a large interaction between the \gls{ps} and \gls{pl}, it is not possible to simply simulate the \gls{hdl} design, it needs a co-simulation between the ARM processor and the \gls{hdl}. This type of co-simulation is complex and very time consuming.

Simulation is an indispensable tool during the design phase, as presented in the results of \gls{riscv} with \gls{tmr}. This work presented a time of 8 minutes for each loop of synthesis, implementation, and simulation. Each simulation loop took 16s of computer time to run only 125$\mu$s of \gls{fpga} time.