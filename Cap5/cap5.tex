%\section{Results and Analysis}
\label{sec:cap5}

This chapter presents the experimental results obtained from the proposed methodology and analyzes their significance. The discussion includes performance evaluation, \gls{fi} results, comparison with reference approaches, and an assessment of the reliability improvements achieved.

\section{Experimental Setup}

The software and hardware environments used in this research are described in \hyperref[sec:cap4-material]{Section~\ref*{sec:cap4-material} -- \textit{FPGA Platform and Toolchain}}. 
Figure~\ref{fig:setup-diagram} presents the connection diagram of the experimental setup used to carry out the tests, while Figure~\ref{fig:setup-pic} shows the actual laboratory configuration adopted during this work. 
The \href{https://ftdichip.com/products/ft2232hq/}{FT2232 communication module} was connected to the \href{https://pynq.readthedocs.io/en/v2.6.1/pynq_libraries/pmod.html}{\gls{pmod}} interface of the \href{https://www.amd.com/en/corporate/university-program/aup-boards/pynq-z2.html}{PYNQ-Z2} board, providing a dual-channel USB-to-serial bridge between the host computer and the \gls{fpga} system.


\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/setup-diagram.png}
    \caption{Interconnection diagram of the main board and the USB-to-Serial interface module.}
    \label{fig:setup-diagram}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{Cap5/setup.jpg}
    \caption{Experimental setup showing the main board (center) and the USB-to-Serial interface module (upper right).}
    \label{fig:setup-pic}
\end{figure}

For a detailed explanation of this experimental setup, see \hyperref[sec:ref-design-arch]{Section 4 - Reference Design Architecture}, \hyperref[sec:fi-strategy]{Section 4 - Fault Injection Strategy} and particularly Figure~\ref{zynq-paper-arch} for a detailed block diagram of the implemented design.

% \section{Baseline Performance Evaluation}
% Before introducing fault-tolerance mechanisms, the system performance is evaluated under normal conditions. This subsection discusses metrics such as resource utilization, operating frequency, and execution latency to establish a baseline reference.

\section{Partial Reconfiguration Results}

This section discusses the \gls{dpr} results, mainly in the reprogramming speed and size of partial bitstreams.

\begin{table}[H]
\centering
\caption{Summary of \acrlong{pr} throughput and configuration time with different \acrshort{dma} settings}
\label{tab:pr_time}
\begin{tabular}{cccc}
\toprule
\textbf{Condition} & \textbf{Time ($\mu$s)} & \textbf{Throughput (Mb/s)} & \textbf{Cache} \\
\midrule
First \gls{dpr} & 897 & 143 & Enabled \\
All others \gls{dpr} & 1.35 & 95195 & Enabled \\
First \gls{dpr} & 1186 & 108 & Enabled and invalidated \\
All others \gls{dpr} & 576 & 222 & Enabled and invalidated \\
First \gls{dpr} & 984 & 130 & Disabled \\
All others \gls{dpr} & 6 & 21117 & Disabled \\
\bottomrule
\end{tabular}
\end{table}

\textcite{Sultana2021} reports that the theoretical throughput of the \gls{pcap} interface is 400~Mb/s when operating on a 32-bit platform, achieving an average throughput of approximately 140~Mb/s. This result is closely aligned with the performance observed for the first \gls{dpr} in this study, as shown in Table~\ref{tab:pr_time}.

According to the results in Table~\ref{tab:pr_time}, during the first \gls{pr}, the achieved throughput approaches the theoretical value. However, from the second reconfiguration onward, certain configurations exhibit unrealistically high speeds. This behavior was identified as a side effect of the small bitstream size used for \gls{pr} and the \gls{ddr} cache present on the Zynq device. When the cache is enabled, write speeds of up to 96~Gb/s can be observed. However, if the cache is explicitly invalidated before each \gls{pr} operation, the throughput stabilizes near the average value and remains below the theoretical limit.

This phenomenon occurs because \gls{pcap} is designed to operate via \gls{dma} transfers from Zynq's \gls{ddr} memory, thus utilizing the cache unless it is explicitly disabled or invalidated.
Higher reconfiguration speeds could potentially be achieved using custom reconfiguration controllers, as demonstrated by ~\textcite{Vipin2014_ZyCAP} on Zynq devices.

For comparison, the total size of the full bitstream is 3.9~Mbit, while each partial bitstream corresponding to the math block is 109~kbit, representing around only 2.8\% of the full configuration size. This significant reduction in bitstream size directly impacts the reconfiguration time, allowing partial reconfiguration to be performed considerably faster than a full device reconfiguration.

This size difference makes \gls{dpr} particularly attractive as a fault-mitigation approach. If a fault is detected in any region of \gls{fpga} and is deemed uncorrectable, a partial reconfiguration can be issued while the static region remains operational. Since \gls{dpr} does not interfere with the execution of other regions, only a small portion of \gls{fpga} needs to be reprogrammed, allowing the system to recover functionality with minimal interruption.

Figure~\ref{fig:menu-blank&dpr-error}(a) shows the time required for the first \gls{dpr} and the application of the blank bitstream. The blanking configuration corresponds to a partial bitstream that contains no logic, serving only as a placeholder to ensure a clean reprogramming of the device. Figure~\ref{fig:menu-blank&dpr-error}(b) illustrates the error that occurs when applying \gls{dpr} without resetting \gls{semip} after a \gls{pr} has been executed. This behavior is discussed in detail in Section~\ref{sec:cap4}, particularly in Item~\ref{itemized-actions-for-dpr&sem}.

\begin{figure}[H]
    \centering
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/menu-blank.png}} 
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/menu-dpr-error.png}}
    \caption{(a) Menu selection for the \acrshort{pr} of the blanking bitstream. (b) Menu indication showing that the \acrshort{pr} failed to load a new bitstream.}
    \label{fig:menu-blank&dpr-error}
\end{figure}

Figure~\ref{fig:menu-mult&mult-ok}(a) shows the \gls{pr} of the \gls{hw} acceleration region as a multiplier using \gls{dpr}. This shows that the \gls{pr} process does not affect other areas of the \gls{fpga}, allowing the system to continue to operate normally. Figure~\ref{fig:menu-mult&mult-ok}(b) presents the correct results obtained from both multiplications, in \gls{hw} and \gls{sw}.

\begin{figure}[H]
    \centering
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/menu-mult.png}} 
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/mult-ok.png}}
    \caption{(a) Menu selection of the multiplier to be applied to the \acrshort{pr}. (b) Multiplication result verification on \acrshort{hw} and \acrshort{sw}.}
    \label{fig:menu-mult&mult-ok}
\end{figure}

Figure~\ref{fig:menu-add&add-ok}(a) shows the \gls{pr} of the \gls{hw} acceleration region into an adder using the \gls{dpr}. This shows that the \gls{pr} process does not affect other areas of the \gls{fpga}, allowing the system to continue to operate normally. Figure~\ref{fig:menu-add&add-ok}(b) presents the correct results obtained from both additions, in \gls{hw} and \gls{sw}.

\begin{figure}[H]
    \centering
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/menu-add.png}} 
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/add-ok.png}}
    \caption{(a) Menu selection of the adder to be applied through the \acrshort{pr}. (b) Addition result verification on \acrshort{hw} and \acrshort{sw}.}
    \label{fig:menu-add&add-ok}
\end{figure}

\subsection{Manual Fault Injection}

After performing the \gls{dpr}, it is possible to manually inject faults using the \gls{semip} to emulate \glspl{see}. For this purpose, the \gls{semip} is commanded via the serial interface to enter injection mode (``I''). Then, the target frame address is sent using the syntax ``N'' followed by the frame address, for example: \texttt{N C0003C440C}.

Figure~\ref{fig:menu-mult-error-fi}(a) shows that the multiplication, executed on \gls{hw}, produces completely incorrect results due to a \gls{fi} targeting a critical bit in frame \texttt{C0003C440C}. It is evident that the output differs from the corresponding \gls{sw} operation and does not match the expected result based on the input operands. Figure~\ref{fig:menu-mult-error-fi}(b) presents another example using different operands, demonstrating that although the output values vary, they remain incorrect.

\begin{figure}[H]
    \centering
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/mult-error.png}} 
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/mult-error2.png}}
    \caption{(a) \acrshort{hw} multiplication error after the injection of a bit flip in frame C0003C440C. (b) Multiplication results obtained with different operands.}
    \label{fig:menu-mult-error-fi}
\end{figure}

Figure~\ref{fig:add-error-fi}(a) shows that the addition, executed on \gls{hw},  produces completely incorrect results due to a \gls{fi} targeting a critical bit in frame \texttt{C0003C440C}. It is evident that the output differs from the corresponding \gls{sw} operation and does not match the expected result based on the input operands. Figure~\ref{fig:add-error-fi}(b) presents another example using different operands, demonstrating that although the output values vary, they remain incorrect.

\begin{figure}[H]
    \centering
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/error_add_after_injection_C0003C440C.png}} 
    \subfigure[]{\includegraphics[width=0.4\textwidth]{Cap5/menu/add_error_other_operand.png}}
    \caption{(a) \acrshort{hw} addition error after the injection of a bit flip in frame C0003C440C. (b) Addition results obtained with different operands.}
    \label{fig:add-error-fi}
\end{figure}

\section{Automated Fault-Injection Campaign Results}
This section presents the results of the automated fault-injection experiments. The effects of single-event upsets (SEUs) on configuration memory and logic are analyzed, highlighting error rates, propagation patterns, and observed system-level failures.

\subsection{Scrubbing and Fault Injection with a FIR Filter}

The first design done to test the \gls{fi} and the memory scrubbing, using the \gls{semip} was with a \gls{dmr} design, where the replicated modules were two \gls{fir} filters.

Figure~\ref{fig:automated_design} illustrates the automated \gls{fi} process. In the Linux terminal, the Python script is executed with a progress bar indicating the percentage of configuration frames already tested. The red square in the figure highlights the \gls{ila} trigger. During execution of \gls{fi}, the design can be monitored through this interface, allowing verification of the internal signals and whether they are affected by the injected bit flip. It is important to note that the monitoring via \gls{ila} is optional and serves only to visual inspect the faults. The design automatically transmits the test results over the serial interface, while the script handles fault injection, output verification, and logging of the frame address and the corresponding results.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/dut_fir/automated_design.png}
    \caption{Representation of the complete automation of the \acrlong{fi} process and the use of the \acrshort{ila} for real-time visualization and debugging of the design behavior during fault injection.}
    \label{fig:automated_design}
\end{figure}

Figure~\ref{fig:error-injection-fir} shows in detail the interface of the automation script. On the left side of the screen, it is possible to observe that the iteration speed is 63.57~iterations/s. This value must be divided by twelve to obtain the actual injection speed. The reason for this is the number of characters in each line of the input file used for fault injection. Each frame address consists of ten characters (e.g., \texttt{C0003C440C}), and each line in the file includes a line feed and a carriage return symbol, totaling twelve characters per injection command.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/dut_fir/error-injection.png}
    \caption{Python script and corresponding visualization showing the real-time progress of the \acrshort{fi} campaign}
    \label{fig:error-injection-fir}
\end{figure}

Figure~\ref{fig:fir_filter_equal} shows an example of a correct visualization of both filters. The error output is equal to zero, since both filters produce exactly the same values for each sample.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/dut_fir/fir_filter_equal.png}
    \caption{\acrshort{ila} waveform capture demonstrating the correct functionality of both filter modules, confirming synchronized operation and expected output behavior.}
    \label{fig:fir_filter_equal}
\end{figure}

Figure~\ref{fig:fir_filter_error} shows an example of an incorrect visualization of both filters. The error output is equal to one, as one of the filters produces a high-peaked response, resulting in different values for each sample.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/dut_fir/error-fir-filter.png}
    \caption{\acrshort{ila} waveform capture illustrating a \acrshort{fi} event that resulted in an erroneous output from the \acrshort{fir} filter, evidencing the effect of a configuration bit upset on functional behavior.}
    \label{fig:fir_filter_error}
\end{figure}

Table~\ref{tab:fir_fi_summary} presents the general fault injection results for the \gls{fir} \gls{dut}. It shows the total number of essential bits within the Pblock region where the \gls{dut} was implemented. Using Equation~\ref{eq:failure_sensitivity}, the failure sensitivity \( r \) obtained is approximately \( 1.1 \times 10^{-3} \).

\begin{table}[H]
\centering
\caption{Summary of configuration bits associated with the \acrshort{fir} region and the critical upsets detected during the \acrlong{fi} campaign.}
\label{tab:fir_fi_summary}
\begin{tabular}{l r}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Total \gls{fpga} bits (\gls{cram}) & 25,697,632 \\
Total essential bits in the \gls{fir} region & 31,020 \\
Total injected bits & 31,020 \\
Critical bits detected: \gls{fir} error & 34 \\
Critical bits detected: AXI bus lock & \gls{na} \\
\bottomrule
\end{tabular}
\end{table}

It is important to note that \gls{semip} operates with \gls{secded} \gls{ecc}. As shown in Table~\ref{tab:fir_fi_summary}, all single-bit faults injected were successfully corrected, allowing the \gls{fir} to continue to operate seamlessly.

To further assess the resilience of the system, a set of \gls{mbu} campaigns was conducted to evaluate how long the design could sustain operation under random fault injection in \gls{fpga} \gls{cram}. After only 50 bit flips, the \gls{fir} exhibited its first error. Since \gls{semip} can correct only one error per frame, multiple upsets began to accumulate, eventually leading to system failure. After 3,564 injections, the design ceased to work and even the serial communication data output was corrupted, rendering the system completely inoperative.

\begin{table}[H]
\centering
\caption{Summary of \acrshort{mbu} fault injection campaign results for the \acrshort{fir} design.}
\label{tab:fir_fi_summary3}
\begin{adjustbox}{max width=\textwidth}
\begin{tabular}{l r}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Total \gls{fpga} configuration bits (\gls{cram}) & 25,697,632 \\
Total essential bits in the \gls{fir} region & \gls{na} \\
Total injected bits & 3,615 \\
Injections without error & 50 \\
Injections with error & 3,564 \\
Injections without response & 1 \\
\bottomrule
\end{tabular}
\end{adjustbox}
\end{table}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\linewidth]{Cap5/dut_fir/total-collapse-fir.png}
    \caption{Random \acrlong{fi} campaign on the \acrshort{fir} design showing progressive error accumulation with \acrlong{ms} disabled.}
    \label{fig:total-collapse-fir}
\end{figure}

Table~\ref{tab:fir_fi_summary3} summarizes the results obtained from the random fault injection campaign until the system became nonfunctional. Figure~\ref{fig:total-collapse-fir} illustrates the resulting build-up of errors, where the entire design becomes defective. The signals shown can be compared with those in Figure~\ref{fig:fir_filter_equal} to observe how far the defective outputs deviate from the correct reference behavior.

In a fault injection experiment, the failure sensitivity \( r \) is defined as the ratio between the number of resulting design failures \( k \) and the total number of injected faults \( n \), as expressed in Equation~\ref{eq:failure_sensitivity} \cite{Wilson2025}.

\begin{equation}
r = \frac{k}{n}
\label{eq:failure_sensitivity}
\end{equation}

Using Equation~\ref{eq:failure_sensitivity}, the failure sensitivity \( r \) obtained for \gls{dmr} \gls{fir} is approximately \( 0.98\).

\subsection{DPR, Scrubbing and Fault Injection with Mathematical Functions}

After the successful implementation of scrubbing using \gls{semip} with \gls{dmr} \gls{fir} filters, the next design iteration incorporated \gls{dpr} into the system functionalities. To fully exploit the resources of \gls{soc}, a \gls{axi} controlled multiplier/adder module was developed. These hardware functions can be selected via a user menu and dynamically reconfigured within \gls{fpga}.

The same automated \gls{fi} campaign was applied; however, during the first attempt, it was not possible to inject faults into all essential bits of the \gls{pr} region, as some injections caused the \gls{ps} ARM processor to stall.

As presented in Table~\ref{tab:math_fi1_summary}, after 21,809 fault injections, the automated script stopped receiving responses from \gls{dut}. Since the device ceased sending status feedback, the script was manually terminated.

Figure~\ref{fig:mult-list-wo-reprogram} and Table~\ref{tab:math_fi1_summary} presents the output of the statistical report script, showing 16,000 configuration frames affected by bit flips that caused \gls{dut} to stop responding.

Initially, all these faults were assumed to correspond to a critical failure that stopped communication with the \gls{dut}. However, a detailed analysis revealed that a bit flip in the \gls{fpga} \gls{cram} corrupted the \gls{axi} bus, leading to a processor stall. The results of this first \gls{fi} campaign are summarized in Table~\ref{tab:math_fi1_summary}.

Once one of the injected frames caused the ARM processor to stall, all subsequent fault injections were affected, as the \gls{axi} bus stopped working, preventing  further communication with \gls{dut}. In other words, 16,000 errors were flagged as unresponsive, but since the first one stalled the processor, the other 15,999 injections are meaningless.

The processor stalls is caused by the \gls{axi} bus, which operates based on a strict valid/ready signal's handshake between the master (e.g., ARM \gls{ps}) and the slave (e.g., the custom \gls{dpr} \gls{ip} core in the \gls{pl}). If the logic in \gls{pl} becomes corrupted due to a bit flip, for instance, in the \gls{axi} interface registers, finite state machines, or control logic of the reconfigurable region, the \texttt{ready} or \texttt{valid} signals may get stuck in an asserted or deasserted state. Since the \gls{axi} protocol does not implement any form of timeout, when the downstream device fails to complete the transaction, the ARM processor waits indefinitely for a response, effectively freezing the execution of the software.

It is important to note that this type of failure cannot be resolved by scrubbing. When the valid or ready signal is not properly asserted toward the \gls{ps}, it becomes necessary to either re-establish these signals or reset the processor, allowing the \gls{axi} bus to restart all transactions from the beginning. A practical mitigation for this issue is the inclusion of a watchdog timer that automatically resets the processor in the event of a stall.

\begin{table}[H]
\centering
\caption{Summary of configuration bits associated with the multiplier region and the critical upsets detected during the initial \acrlong{fi} campaign.}
\label{tab:math_fi1_summary}
\begin{tabular}{l r}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Total \gls{fpga} bits (\gls{cram}) & 25,697,632 \\
Total essential bits in the multiplier region & 70,182 \\
Total injected bits & 37,809 \\
Critical bits detected: Multiplication error & 7 \\
Critical bits detected: AXI bus lock & 16,000 \\
\bottomrule
\end{tabular}
\end{table}

To overcome this limitation, the automated script was updated so that whenever \gls{dut} stopped responding, the processor was reset and \gls{fpga} was fully reprogrammed. This modification allowed the experiments to continue without manual intervention and resulted in more stable executions, resulting in only three configuration frames causing this type of critical failure that led the ARM processor to stall.

Table~\ref{tab:math_fi2_summary} presents the results obtained with the updated script, in which all essential bits within the \gls{pr} regions were successfully tested against bit flips. The table also summarizes the error statistics and the occurrences of \gls{axi} bus stalls.

Figure~\ref{fig:mult-list-reprogram} shows the completion of the \gls{fi} campaign for all essential bits in the \gls{pr} region, applying reprogramming whenever a \gls{ps} stall was detected.

\begin{table}[H]
\centering
\caption{Summary of configuration bits associated with the multiplier region and the critical upsets detected during the \acrlong{fi} campaign with \acrshort{ps} stall detection.}
\label{tab:math_fi2_summary}
\begin{tabular}{l r}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Total \gls{fpga} bits (\gls{cram}) & 25,697,632 \\
Total essential bits in the multiplier region & 70,182 \\
Total injected bits & 70,182 \\
Critical bits detected: Multiplication error & 29 \\
Critical bits detected: AXI bus lock & 3 \\
\bottomrule
\end{tabular}
\end{table}

As shown in Table~\ref{tab:math_fi2_summary}, all injected faults were single-bit flips, and since \gls{semip} operates with a \gls{secded} \gls{ecc}, all 29 critical bits that caused errors in multiplication performed by \gls{hw} were successfully corrected by scrubbing. However, the three critical bits that caused the \gls{axi} bus to lock were only corrected after resetting \gls{ps} and performing a full reprogramming of \gls{fpga}.

Using Equation~\ref{eq:failure_sensitivity}, the failure sensitivity \( r \) obtained for this second experiment is approximately \( 0.41 \times 10^{-3} \) for multiplication error and \( 0.043 \times 10^{-3} \) for \gls{axi} stall.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{Cap5/mult/mult_injection_results-wo_reprogram.png}
    \caption{Automated \acrlong{fi} results obtained without the reprogramming capability.}
    \label{fig:mult-list-wo-reprogram}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{Cap5/mult/mult-error-reprogram.png}
    \caption{Automated \acrlong{fi} results obtained with the reprogramming capability enabled.}
    \label{fig:mult-list-reprogram}
\end{figure}

Figure~\ref{fig:mult-list-reprogram} shows only a subset of the addresses that caused faults. For the complete list of all addresses that produced errors during this \gls{fi} campaign, refer to \hyperref[apeB:mult-list-w-axi-error]{Appendix~B — Multiplication SEU AXI Error (ARM Stall) List} and \hyperref[apeB:mult-list-w-error]{Appendix~B — Multiplication SEU Error List}.

The \gls{ms} based on the \gls{semip} demonstrates high efficiency, providing substantial fault-mitigation benefits with a logic utilization below 2\% of the total \gls{fpga} resources, as detailed in Appendix~\ref{apeC}.

\section{RISC-V with Triple Modular Redundancy}

Continuing the evaluation of \gls{nmr}, the \gls{dmr} configuration was extended to a \gls{tmr} scheme. For this purpose, a different \gls{dut} was selected: the \gls{riscv} processor. The chosen implementation of the \gls{cpu} was the open-source PicoRV32 core.

Table~\ref{tab:tmr_resource_comparison} presents the resource utilization results comparing the simplex and \gls{tmr} implementations of the PicoRV32 \gls{cpu}. The triplication of the processor and inclusion of word voters resulted in increased resource consumption relative to the baseline design. Synthesis performed in Vivado~2018.3 reported a 3.09$\times$ increase in Slice LUT usage and a 3.35$\times$ increase in Slice Flip-Flops.

\begin{table}[H]
\centering
\caption{Resource utilization comparison between simplex and \acrshort{tmr} implementations of the PicoRV32 \acrshort{cpu}.}
\label{tab:tmr_resource_comparison}
\begin{adjustbox}{max width=\textwidth}
\begin{tabular}{lccc}
\hline
\textbf{Resource} & \textbf{Simplex (1 Core)} & \textbf{\gls{tmr} (3 Cores)} & \textbf{Increase Ratio} \\
\hline
Slice LUTs & 887 & 2,737 & 3.09 \\
Slice Flip-Flops (FFs) & 517 & 1,731 & 3.35 \\
\hline
\end{tabular}
\end{adjustbox}
\end{table}

\subsection{Simulated Fault Injection}

In this case, the \gls{fi} method was performed through simulation using the mutant-based approach. This method was selected to evaluate the \gls{fi} time and to compare the results with those obtained from hardware-based emulation.

Figure~\ref{fig:risc-simul-hw-console} shows the simulation results of the \gls{dut}. The console output displays the greeting message generated by a simple C-written firmware, executed by each \gls{cpu} core. The read of each word-voter output is presented, showing its status, being equal to zero means no fault. The message output is word-voted, and since this is a \gls{tmr} implementation, the system can mask a fault in up to one of the modules.

% \begin{figure}[H]
%     \centering
%     \includegraphics[width=0.75\linewidth]{Cap5/rv_simul/simulation_result_hello_world.png}
%     \caption{Self-check simulation setup in which the processor cores execute test firmware transmitting the message “Hello World” through the serial output interface.}
%     \label{fig:risc-simul-hw-console}
% \end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/rv_simul/tmr-status.png}
    \caption{Self-check simulation setup in which the processor cores execute test firmware transmitting the message “Hello World” through the serial output interface and the status of each voter.}
    \label{fig:risc-simul-hw-console}
\end{figure}

% ===========================
% No Fault Case
% ===========================
Figure~\ref{fig:no-riscv-fault} illustrates the state of the simulation without injection of faults. In this scenario, all three cores execute the same firmware, producing identical outputs. The voter therefore outputs the correct value, and no fault condition is observed.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/rv_simul/all_modules_ok.png}
    \caption{Fault-free operation of the \acrshort{tmr}-protected PicoRV32 processor, showing memory write data signals and corresponding serial output during normal execution.}
    \label{fig:no-riscv-fault}
\end{figure}

% ===========================
% Single Fault Case
% ===========================
Figure~\ref{fig:1-riscv-fault} presents the case where a single bit flip was injected into Core\#1. Although one core produces an incorrect result, the majority voter successfully masks the fault, and the overall system output remains correct. The serial interface output and memory write signals confirm the proper operation, demonstrating the effectiveness of the \gls{tmr} scheme in tolerating single faults.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/rv_simul/1_module_fault.png}
    \caption{Single fault case showing a bit flip injected in core 1 (A input). Despite the injected error, the serial interface output and memory write signals remain correct due to fault masking by the word voter (signal OUT).}
    \label{fig:1-riscv-fault}
\end{figure}

% ===========================
% Double Fault Case
% ===========================
Figure~\ref{fig:2-riscv-fault} shows the scenario in which two cores experience the same injected error. In this case, the voted output becomes incorrect, preventing the system from booting properly and generating the expected “Hello World” message. This shows that when more than one module is affected simultaneously, the \gls{tmr} architecture cannot maintain functional correctness.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/rv_simul/2_modules_equl_fault.png}
    \caption{Double fault scenario: two cores experience the same injected error. The voted output becomes incorrect, preventing the system from booting and displaying the “Hello World” message.}
    \label{fig:2-riscv-fault}
\end{figure}

% ===========================
% Multiple Fault Case
% ===========================
Finally, Figure~\ref{fig:3-riscv-fault} represents the multiple-fault condition, where all three processor cores exhibit different faulty outputs. As a result, no valid majority can be established, and the ERROR signal is asserted, indicating a complete divergence among the redundant modules.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/rv_simul/3_modules_diff_faults.png}
    \caption{Multiple fault scenario: all cores are affected, preventing a valid majority vote. The ERROR signal indicates divergence among the three modules.}
    \label{fig:3-riscv-fault}
\end{figure}

\subsection{Emulated Fault Injection}

The emulated \gls{fi} campaign using the \gls{semip} was performed on the \gls{tmr}-protected \gls{riscv} architecture. 

The \gls{fi} process targeted the configuration frames corresponding to the region where Core~\#1 was implemented. 
The design was physically divided into three \textit{pblocks}: one dedicated to the serial interface (\gls{uart}), another shared between Cores~\#2 \&~\#3, and one exclusively reserved for Core~\#1 (My \acrshort{dut} pblock in region X1Y0), as shown in Figure~\ref{fig:2pblocks}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{Cap5/rv_hw/pblock-outroscores.png}
    \caption{\acrshort{riscv} processor implemented in the \acrshort{fpga} using \acrshort{tmr}, physically partitioned into distinct \textit{pblocks}.}
    \label{fig:2pblocks}
\end{figure}

Table~\ref{tab:rv1_fi1_summary} summarizes the errors detected during the campaign.

\begin{table}[H]
\centering
\caption{Summary of configuration bits associated with the RISC-V Core~\#1 region and the critical upsets detected during the first \acrlong{fi} campaign.}
\label{tab:rv1_fi1_summary}
\begin{tabular}{l r}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Total \gls{fpga} bits (\gls{cram}) & 25,697,632 \\
Total essential bits in the multiplier region & 2,184 \\
Total injected bits & 2,184 \\
Critical bits masked (0 core faulty) & 96 \\
Critical bits masked (1 core faulty) & 2,088 \\
Critical bits detected (>1 core faulty) & 0  \\
\bottomrule
\end{tabular}
\end{table}

Although 2,088 critical upsets were detected, the system continued to operate correctly since the \gls{tmr} voter successfully masked all single-core faults.

A second campaign was conducted targeting a different region with a larger number of essential bits, as summarized in Table~\ref{tab:rv1_fi2_summary}.

\begin{table}[H]
\centering
\caption{Summary of configuration bits associated with the RISC-V Core~\#1 region and the critical upsets detected during the second \acrlong{fi} campaign.}
\label{tab:rv1_fi2_summary}
\begin{tabular}{l r}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Total \gls{fpga} bits (\gls{cram}) & 25,697,632 \\
Total essential bits in the multiplier region & 346,659 \\
Total injected bits & 1,245 \\
Critical bits masked (0 core faulty) & 96 \\
Critical bits masked (1 core faulty) & 914 \\
Critical bits detected (>1 core faulty) & 235 \\
\bottomrule
\end{tabular}
\end{table}

Using Equation~\ref{eq:failure_sensitivity}, the calculated failure sensitivity \( r \) for this experiment is approximately \( 0.19 \).

Figures~\ref{fig:ila-rv-allOK} and~\ref{fig:ila-rv-1KO} illustrate the \gls{ila} captures obtained before and after \gls{fi}.

In the first case, all cores operate synchronously, producing identical outputs. After injection, Core~\#1 exhibits corrupted data, yet the \gls{tmr} voter successfully masks the fault, maintaining system stability and correct functionality.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/rv_hw/il-rv-allOK.png}
    \caption{\acrshort{ila} capture of the \acrshort{riscv} system showing all cores writing identical data to memory, indicating fault-free operation.}
    \label{fig:ila-rv-allOK}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap5/rv_hw/il-rv-core1KO.png}
    \caption{\acrshort{ila} capture showing a corrupted memory write caused by a fault injection in Core~\#1. The divergence was masked by the majority voter, ensuring continued operation.}
    \label{fig:ila-rv-1KO}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%IMPACT
\section{Impact of Mitigation Techniques}
\label{sec:impact-mitigation}

This section discusses the general impact of the mitigation strategies implemented in this study, including \gls{nmr}, \gls{ms}, and \gls{dpr}. The results obtained are compared with the unprotected baseline designs, highlighting measurable improvements in reliability, recovery coverage, and recovery time, as well as the associated resource trade-offs.

\subsection{Recovery Coverage and Failure Sensitivity}

The results obtained from the \gls{fir} and math function tests clearly demonstrate that recovery coverage is strongly influenced by the mitigation mechanisms adopted. In the unprotected \gls{fir} design, the first failure occurred after only 50 bit flips during random fault injection in \gls{cram}. Since \gls{semip} operating under \gls{secded} \gls{ecc} can correct only one error per frame, the accumulation of multi-bit upsets (\glspl{mbu}) caused the system to collapse after 3,564 injections, rendering even the serial interface inoperative. The corresponding failure sensitivity, computed as \(r = k/n\), reached approximately \(r = 0.98\), indicating that nearly every injected fault at this stage produced an observable malfunction.

When scrubbing was enabled and coupled with redundancy, the results improved significantly. All single-bit upsets were transparently corrected by \gls{semip}, and \gls{fir} continued to operate seamlessly. This confirms that the combination of internal scrubbing and design-level redundancy provides efficient protection against transient \glspl{seu}, substantially reducing the effective failure rate.

\subsubsection{Recovery Coverage Evaluation}

Recovery coverage (\(RC\)) quantifies the fraction of injected faults that were successfully masked, corrected, or recovered by the mitigation strategies implemented. It is defined by Equation~\ref{eq:fault_coverage}:

\begin{equation}
RC = 1 - \frac{k}{n}
\label{eq:fault_coverage}
\end{equation}

where \(k\) represents the number of injected faults that caused functional failures and \(n\) is the total number of injected faults during the campaign.

Table~\ref{tab:fault_coverage_summary} summarizes the calculated recovery coverage for each design and mitigation level evaluated.

\begin{table}[H]
\centering
\caption{Summary of recovery coverage obtained for different designs and mitigation strategies.}
\label{tab:fault_coverage_summary}
\begin{adjustbox}{max width=\textwidth}
\begin{tabular}{l r r r}
\toprule
\textbf{Design / Mitigation Level} & \textbf{Total Injections ($n$)} & \textbf{Failures ($k$)} & \textbf{Recovery Coverage (\%)} \\
\midrule
\gls{fir} (no scrubbing, \gls{mbu}) & 3,615   & 3,564   & 1.4   \\
\gls{fir} (\gls{semip} scrubbing)   & 31,020  & 34      & 99.9  \\
Multiplier (initial)                & 37,809  & 16,007  & 57.7  \\
Multiplier (with recovery)          & 70,182  & 32      & 99.95 \\
\gls{tmr} \gls{riscv} (Core\#1)     & 2,184   & 0       & 100  \\
\gls{tmr} \gls{riscv} (Random)      & 1,245   & 235     & 81.0 \\
\bottomrule
\end{tabular}
\end{adjustbox}
\end{table}

As shown in Table~\ref{tab:fault_coverage_summary}, recovery coverage increased from only 1.4\% in the unprotected design to 99.9\% when internal scrubbing was enabled. The combination of scrubbing, processor reset, and reprogramming achieved a near-complete recovery rate of 99.95\%, confirming the effectiveness of the proposed multi-layered mitigation strategy to enhance the reliability based on \gls{sram}-based \gls{fpga}.

The results presented for the \gls{riscv} system in Table~\ref{tab:fault_coverage_summary} show that when faults were injected exclusively into the \gls{cpu} Core~\#1 region, all detected errors in voters were successfully masked, allowing the system to continue operating without functional failure. However, when random \gls{fi} campaigns were carried out throughout \gls{cram}, the system experienced a failure after approximately 1,235 injected bit flips.

\subsection{Error Recovery and System Availability}

The addition of \gls{dpr} extended the fault-tolerance capability of the system by enabling localized recovery of defective modules. The experimental results in Section~\ref{sec:cap5} showed that each partial bitstream represented only 2.8\% of the full configuration file, allowing reconfiguration to be performed more than an order of magnitude faster than full device reprogramming. As a result, even in the cases of unrecoverable upsets, only the affected region was reconfigured, keeping the static portion of the design operational. This characteristic is crucial for mission-critical systems where up-time and continuity are required.

The integration of automated \gls{fi} with recovery mechanisms also proved effective in identifying unrecoverable failures in the \gls{axi} interconnect. After the implementation of processor reset and full reprogramming logic, the number of unrecoverable stalls dropped from 16,000 to just 3 out of 70,182 injected faults, corresponding to a two-order-of-magnitude improvement in fault recovery efficiency. The updated campaign achieved a failure sensitivity of \( r \approx 0.41 \times 10^{-3} \) for regular computational errors and \( r \approx 0.043 \times 10^{-3} \) for \gls{axi} stalls.

\subsection{Redundancy and Fault Masking Effectiveness}

In the \gls{tmr}-protected PicoRV32 processor, simulated fault injection demonstrated the expected masking behavior. With a single faulty core, the system maintained correct outputs due to the majority voting logic. When two cores were affected simultaneously, the output diverged, and the system failed to boot, validating the \gls{tmr} assumption that it can tolerate only one simultaneous error. In triple faults, the majority voter detected the full disagreement, asserting the error signal. 

The implementation of \gls{tmr} increased the usage of logic resources by approximately 3.1$\times$ in LUTs and 3.3$\times$ in flip-flops, consistent with theoretical expectations. However, this overhead was justified by the considerable improvement in reliability and error detection coverage. The inclusion of word-level voters instead of bitwise voters also enhanced error observability by exposing multi-module inconsistencies that would otherwise remain masked. The results show, in both the simulation and the emulated \gls{fi} experiments, that the redundancy of the system effectively masks faults and enables error detection and correction before accumulation occurs.

\subsection{Reliability Gains and Trade-offs}

In general, the combination of \gls{dpr}, \gls{semip}-based scrubbing, and \gls{tmr} achieved a complete balance between reliability and resource overhead. Each mitigation layer addressed a specific reliability dimension:
\begin{itemize}
    \item \textbf{Scrubbing} ensured automatic correction of transient single-bit faults in the configuration memory.
    \item \textbf{Redundancy} masked transient faults at the functional level, improving system-level recovery coverage.
    \item \textbf{Dynamic Partial Reconfiguration} provided fast recovery from permanent or multi-bit faults while maintaining uninterrupted system operation.
\end{itemize}

Quantitatively, the adoption of these techniques reduced the system failure rate by more than two orders of magnitude compared to unprotected configurations. Although this came at the cost of a threefold increase in resource utilization and a moderate increase in power consumption, the trade-off is acceptable for aerospace and mission-critical applications, where reliability and maintainability outweigh area constraints.

\subsection{Summary of Mitigation Impact}

In summary, the proposed architecture effectively demonstrated the following:
\begin{itemize}
    \item Recovery coverage increased from less than 10\% in unprotected designs to more than 99\% when scrubbing and redundancy were combined.
    \item The \gls{mttr} improved significantly with \gls{dpr}, allowing for rapid reconfiguration of faulty regions.
    \item The failure sensitivity metric decreased by more than three orders of magnitude between the unprotected and protected configurations.
\end{itemize}

These results confirm that an integrated mitigation strategy that combines redundancy, internal scrubbing, and partial reconfiguration is a powerful approach to enhance the reliability of \gls{sram}-based \glspl{fpga} in space and high-radiation environments. These characteristics make the proposed platform suitable for deployment in harsh conditions, particularly in non-critical instruments and communication systems, as discussed in~\textcite{Brosser2014}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%IMPACT

% \section{Comparative Analysis with Existing Approaches}
% This section compares the proposed solution to similar works in the literature. A summary table highlights differences in methodology, fault coverage, resource overhead, and performance impact.

\clearpage
\section{Discussion of Findings}
The key findings are synthesized and interpreted in terms of their practical implications. The trade-offs between reliability, performance, and resource consumption are critically assessed, providing valuable insight for future improvements.

An important finding of this study was the detection of \gls{ps}--\gls{axi} bus stalls during fault emulation, which highlights one of the major advantages of performing \gls{fi} directly on real \gls{fpga} hardware. This type of failure, which arises from complex interactions between \gls{ps} and \gls{pl}, cannot be accurately captured through traditional \gls{hdl}-only simulations. Instead, such events would require co-simulation between the ARM processor and the \gls{hdl} design, a process that is both computationally expensive and time-consuming.

Nevertheless, simulation remains an indispensable tool during the initial design phase. For example, the \gls{riscv} \gls{tmr} evaluation in this work required approximately 8~minutes for each synthesis–implementation–simulation loop, with each run consuming approximately 1~minute of host computation to simulate only 125$\mu$~seconds of \gls{fpga} time. Given that the average emulation-based \gls{fi} rate achieved in this study was about six faults per second, it is evident that simulation-based injections are several orders of magnitude slower than hardware emulation using the \gls{semip}. As noted by \textcite{Garcia2020}, this makes large-scale fault campaigns impractical as design complexity increases.

As discussed by \textcite{Fibichi2019}, \gls{fi} systems that interface through slower serial communication links, such as the USB-to-serial converter used in this research, are constrained by latency introduced by both \acrlong{sw} and \acrlong{hw} communication layers. The minimum achievable duration of a \acrlong{fi} sequence reported by \textcite{Fibichi2019} is 20~ms. In comparison, the average bit-flip rate achieved in this work was approximately 5.4~bit flips per second.

As presented by \textcite{Leon2024_VeeR_EH1_SEU}, their proposed \gls{fi} through \gls{hw} operate at approximately 0.2~s per injection on a single test-board, with full parallelization possible by adding more boards. This result is comparable to the performance achieved in this work. Similarly, \textcite{Garcia2020} reported an average rate of 3~bit flips per second, nearly half the throughput demonstrated here. In another study, \textcite{Aranda2019} carried out a 20-hour \gls{fi} campaign to inject 9,405~faults, whereas the proposed setup in this work can inject approximately 18,000~bit flips per hour, demonstrating a substantial improvement in injection efficiency.

\clearpage
\section{Limitations}
\label{sec:limitations}

Although the proposed platform effectively integrates \gls{nmr}, \gls{dpr}, and \gls{ms} for improved \gls{fpga} reliability, several limitations remain. The use of \gls{dpr} introduces reconfiguration latency, and hardware redundancy increases the utilization of logic. The methodology was validated on medium-scale designs, therefore, scaling to larger \glspl{soc} may involve synchronization and power challenges. All experiments relied on AMD/Xilinx Zynq-7000 devices and the Vivado~2018.3 toolchain, which limits cross-vendor portability.

The automated \gls{fi} framework achieved moderate throughput due to serial communication constraints, and only emulated tests were conducted, no radiation exposure experiments were performed. The Fault-tolerance mechanisms were applied mainly to the \gls{pl}, leaving the \gls{ps} domain unprotected. Only  internal scrubber was implemented and tested, though practical, the \gls{semip} shares resources with user logic and may become a \gls{spof}. Additionally, secure storage of the golden bitstream was not addressed, which could compromise recovery reliability.

Future work should explore external and independent scrubbing solutions, secure bitstream storage methods (e.g., \gls{rom}, \gls{otp}), the integration of \gls{ecc}-protected memories, and validation under real radiation environments. These perspectives are further discussed in Section~\ref{sec:cap6}.
