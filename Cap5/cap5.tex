%\section{Results and Analysis}
\label{sec:cap5}

This chapter presents the experimental results obtained from the proposed methodology and analyzes their significance. The discussion includes performance evaluation, fault-injection outcomes, comparison with reference approaches, and an assessment of the reliability improvements achieved.

\section{Experimental Setup}

The software and hardware used in this research is discussed in \hyperref[sec:cap4-material]{Section 4 - FPGA Platform and Toolchain}. Figure~\ref{fig:setup-diagram} illustrates the diagram of connections in order to conduct the research. Figure~\ref{fig:setup-pic} illustrates the setup used during this work. The \href{https://ftdichip.com/products/ft2232hq/}{FT-2232 module} is connected to the \href{https://pynq.readthedocs.io/en/v2.6.1/pynq_libraries/pmod.html}{\gls{pmod}} connector of the \href{https://www.amd.com/en/corporate/university-program/aup-boards/pynq-z2.html}{Pynq-Z2}.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Cap5/setup-diagram.png}
    \caption{Interconnection diagram of the main board and the USB to Serial Interface module}
    \label{fig:setup-diagram}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=0.75\linewidth]{Cap5/setup.jpg}
    \caption{Setup of the main board (center) and the USB to Serial Interface module (up right)}
    \label{fig:setup-pic}
\end{figure}

\section{Baseline Performance Evaluation}
Before introducing fault-tolerance mechanisms, the system performance is evaluated under normal conditions. This subsection discusses metrics such as resource utilization, operating frequency, and execution latency to establish a baseline reference.

\section{Partial Reconfiguration Results}

\begin{table}[H]
\centering
\caption{Partial Reconfiguration Time.}
\label{tab:pr_time}
\begin{tabular}{lccc}
\toprule
\textbf{Condition} & \textbf{Time ($\mu$s)} & \textbf{Throughput (Mb/s)} & \textbf{Cache} \\
\midrule
First \gls{dpr} & 897 & 143 & Enabled \\
All others \gls{dpr} & 1.35 & 95,195 & Enabled \\
First \gls{dpr} & 1,186 & 108 & Enabled and invalidated \\
All others \gls{dpr} & 576 & 222 & Enabled and invalidated \\
First \gls{dpr} & 984 & 130 & Disabled \\
All others \gls{dpr} & 6 & 21,117 & Disabled \\
\bottomrule
\end{tabular}
\end{table}

\section{Fault-Injection Campaign Results}
This section presents the results of the systematic fault-injection experiments. The effects of single-event upsets (SEUs) on configuration memory and logic are analyzed, highlighting error rates, propagation patterns, and observed system-level failures.

\subsection{FIR Filter block}

\begin{table}[H]
\centering
\caption{Summary of configuration bits and detected critical upsets in the multiplier region.}
\label{tab:fir_fi_summary}
\begin{tabular}{l r}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Total FPGA bits (CRAM) & 25.697.632 \\
Total essential bits in the \gls{fir} region & 31.020 \\
Total injected bits & 31.020 \\
Critical bits detected: Multiplication error & 34 \\
Critical bits detected: AXI bus lock & \gls{na} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Math \glsentrytext{dpr} block}

\begin{table}[H]
\centering
\caption{Summary of configuration bits and detected critical upsets in the multiplier region.}
\label{tab:math_fi_summary}
\begin{tabular}{l r}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Total FPGA bits (CRAM) & 25.697.632 \\
Total essential bits in the multiplier region & 70.182 \\
Total injected bits & 70.182 \\
Critical bits detected: Multiplication error & 29 \\
Critical bits detected: AXI bus lock & 3 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Scrubbing and Fault Injection with a FIR Filter}

The first design done to test the \gls{fi} and the memory scrubbing, using the \gls{semip} was with a \gls{dmr} design, where the replicated modules were two \gls{fir} filters.

The idea of using \gls{fir} filters is because they are pure mathematical modules and so they do not need any kind of reset or resynchronization after a \gls{fi} and a repair 

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Cap5/dut_fir/automated_design.png}
    \caption{Complete automation of the \gls{fi} and visualization of the \gls{ila} to "debug" the design.}
    \label{fig:automated_design}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Cap5/dut_fir/error-injection.png}
    \caption{Script and visualization of the progress of \gls{fi} campaign.}
    \label{fig:error-injection-fir}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Cap5/dut_fir/fir_filter_equal.png}
    \caption{\gls{ila} capture, showing correct function of both filters.}
    \label{fig:fir_filter_equal}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Cap5/dut_fir/error-fir-filter.png}
    \caption{\gls{ila} capture, showing a \gls{fi} that caused an rror in the output of the \gls{fir} filter.}
    \label{fig:fir_filter_error}
\end{figure}

Simulation-based fault injection provides high controllability and low cost, as no actual device is required. It suffers, however, from long simulation times, especially for complex systems [7][8]. It may also fail to identify complex faulty behaviors, especially when simulations are done at high abstraction levels. When the goal is to evaluate the effects of faults in the FPGA bitstream, the use of an actual device is near mandatory. The effects of configurations unforeseen by manufacturers and the lack of low level schematics available to the end user make it almost infeasible to perform accurate simulation-based fault injection for this case. \textcite{NazarCarro_DFT_FastSingleFPGA,Antoni2003}

The proposed injection system also presents some limitations when compared to other approaches. Running at about 0.2 s per injection in a single test-board environment (fully parallel execution is possible by adding more boards), it is slower than non fine-grain software simulators, such as GEM5 [32], virtual platforms like SOFIA [34] and, potentially, RTL-modified based testing [22] on FPGA. However, equivalent state-of-the-art fine-grain software RTL simulators run at as low as 1 KHz on modern CPUs [49,50] making simulation at this granularity much slower than the proposed one \cite{Leon2024_VeeR_EH1_SEU}.

\section{Impact of Mitigation Techniques}
The results obtained after implementing the proposed fault-mitigation strategies are discussed. Comparisons are made between unprotected and protected designs, focusing on improvements in fault coverage, error recovery, and reliability metrics.

\section{Comparative Analysis with Existing Approaches}
This section compares the proposed solution to similar works in the literature. A summary table highlights differences in methodology, fault coverage, resource overhead, and performance impact.

\section{Discussion of Findings}
The key findings are synthesized and interpreted in terms of practical implications. The trade-offs between reliability, performance, and resource consumption are critically assessed, providing information for future improvements.

As discussed in \textcite{Fibichi2019}, \gls{fi} systems that interface through slower serial communication links, such as the USB-to-serial converter used in this research, are constrained by the latency introduced by the software and hardware communication stack. The minimum achievable fault injection sequence duration achieved by \textcite{Fibichi2019} is reported to be 20 milliseconds. The reported \gls{fi} reported by is 4.6 ms.