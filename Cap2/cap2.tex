%\section{Concepts and Literature Review}
\label{sec:cap2}

This chapter presents the essential concepts and summarizes the state-of-the-art in FPGA reliability, fault-tolerant architectures, and error mitigation strategies. It provides the foundation upon which this dissertation builds, highlighting key technologies, methods, and prior contributions in the field.

\section{\glsentrytext{fpga}}
A \gls{fpga} is a reconfigurable logic device or a programmable \gls{ic} widely used for the implementation of digital systems.

\glspl{fpga} are semiconductor devices that can be configured by the user, even after deployment, to implement custom digital circuits. Their programmable nature enables rapid prototyping, hardware acceleration, and long-term design flexibility. This section introduces FPGA architectures, focusing on the role of configurable logic blocks, routing resources, and configuration memory.

\glspl{fpga} are successful platforms because they combine the flexibility of software with the speed of hardware, providing adaptable computing cores and high-throughput processing of data streams. They are particularly attractive compared to \glspl{asic} due to their shorter development time and costs, and their ability to be reconfigured \citeauthor{8524728}.

\subsection{Core Structure and Components}

An \gls{fpga} is essentially a complex heterogeneous device implemented on a single chip. Its basic structure consists of an array or matrix of interconnected configurable elements:

\subsection{Configurable Logic Blocks}
These are the elementary logic blocks used to implement the desired logic functions. \glspl{clb} (sometimes called Logic Cells or Logic Array Blocks) perform simple combinational and sequential logic.
\begin{itemize}
    \item They typically comprise \glspl{lut}, which perform logical operations; \glspl{ff}, which serve as storage elements for sequential logic; and carry logic.
    \item The \glspl{lut} function as small memories that serve as a truth table for logic functions.
\end{itemize}

\subsection{Routing and Interconnect Resources}
These resources, including \glspl{sb}, \glspl{cb}, and \glspl{pip}, form a network that electrically interconnects the \glspl{clb}, I/O blocks, and embedded resources to implement complex systems.

\subsection{Input/Output Blocks (IOBs)}
These blocks are positioned around the logic core to interface the internal logic with the external environment, handling data input and output.

\subsection{Specialized Heterogeneous Resources}
Modern FPGAs also include various specialized resources beyond the basic structure, such as:
\begin{itemize}
    \item \textbf{Embedded Memories}, such as \glspl{bram}.
    \item \textbf{Arithmetic Resources}, such as \gls{dsp} units.
    \item \textbf{Processing Resources}, which can be hard cores (e.g., ARM Cortex processors in Xilinx Zynq-7000 All Programmable System-on-Chip (APSoC)) or soft processors implemented using programmable logic.
    \item \textbf{Clock-management resources}.
\end{itemize}

As shown in Figure~\ref{fpga-arch}, the \gls{fpga} architecture consists of configurable logic blocks, routing resources, and \gls{io} blocks.

\begin{figure}[ht]
\centering
\includegraphics[width=0.75\textwidth]{Cap2/fpga-structure.png}
\caption{FPGA Structure. Adapted from \citeauthor{Marioli2010}}\label{fpga-arch}
\end{figure}

\subsection{Configuration and Reprogrammability}

FPGAs are programmable devices whose behavior is defined by a \textit{bitstream}. This bitstream contains all the information needed to configure the circuit in the FPGA architecture, mapping the user-defined \gls{hdl} design to the available logic and routing elements.

The type of \gls{cram} used dictates the device's characteristics:

\begin{itemize}
    \item \textbf{\gls{sram}-based \glspl{fpga}:} These are the most widely used commercial FPGAs due to their high reconfiguration flexibility, capability for integrating complex systems, and competitive costs. They use \gls{sram} cells, known as \gls{cram}, to store the configuration. This technology allows FPGAs to be reprogrammed an infinite number of cycles and, crucially, permits \textit{\gls{dpr}}, meaning parts of the configuration can be changed during runtime. A significant drawback is that the \gls{sram} cells are volatile and highly susceptible to radiation-induced faults such as \glspl{seu}, \cite{Adria2023}.

    \item \textbf{Flash-based \glspl{fpga}:} These are reconfigurable and non-volatile, meaning the configuration memory is immune to \glspl{seu}. However, they may have lower capacity and fewer reprogramming cycles compared to SRAM devices \cite{Wubs2023}.

    \item \textbf{Antifuse \glspl{fpga}:} These are One-Time Programmable (OTP) devices whose configuration cannot be changed once set. Their configuration memory is immune to radiation effects, making them suitable for harsh environments, but they offer lower logic capacity \cite{Garcia2020}.
\end{itemize}

\section{Sources of Faults in \glsentrytext{fpga}}
FPGA devices are susceptible to faults that arise from various sources, such as radiation-induced soft errors, aging effects, manufacturing defects, and electromagnetic interference. In particular, SRAM-based FPGAs are vulnerable to \glspl{seu} that can corrupt configuration bits or logic states. This section classifies faults into transient, intermittent, and permanent categories, discussing their mechanisms and impact on system behavior.

\subsection{Single Event Upsets (SEUs) and Failure Modes}

The majority of modern, high-density FPGAs rely on \gls{sram} cells to store their configuration bitstream. 
This \gls{cram} defines the functionality of logic blocks (\glspl{lut} and \glspl{ff}) and all internal interconnections. 
Unfortunately, this reliance on volatile SRAM renders FPGAs highly susceptible to soft errors induced by high-energy ionizing radiation, 
a phenomenon particularly severe in environments such as space.

\subsubsection{Single Event Upsets (SEUs)}
The principal threat to FPGA reliability is the \textit{Single Event Upset (SEU)}, a non-destructive event where a single particle strike flips the state of a memory bit. In \gls{sram}-based FPGAs, \glspl{seu} are a major concern because the altered configuration bits can permanently
change the implemented logic and routing, leading to persistent malfunctions.

\subsubsection{System Failure Types}
These faults manifest themselves as two major types of system failures:

\begin{enumerate}
    \item \textbf{Silent Data Corruptions (SDCs):} Incorrect computations leading to incorrect application output.
    \item \textbf{Single Event Functional Interrupts (SEFIs):} Non-destructive disruptions often caused by upsets in critical control logic (such as clock or reset), leading to processor crashes, hangs, or loss of functionality.
\end{enumerate}

\subsubsection{Reliability Concept}
The concept of reliability relies on addressing the chain of events: 
a \textit{fault} (abnormal condition) leads to an \textit{error} (discrepancy in value), which, if propagated, causes a \textit{system failure} (inability to perform the required function).

\section{Fault-Tolerance and Mitigation Techniques}
Numerous methods have been proposed to enhance the resilience of \gls{fpga} systems. Redundancy-based approaches such as \gls{tmr} and \gls{nmr}, memory scrubbing, and configuration repair are among the most widely used. This section surveys existing techniques, comparing their error coverage, resource overhead, and suitability for different applications.

\subsection{\glsentrytext{dpr} in Fault Mitigation}

\gls{dpr} allows \textit{run-time} modification of specific regions of the FPGA without interrupting the operation of the application layer. 

However, this technique alone cannot detect configuration errors and therefore must be combined with other fault detection mechanisms, such as those based on redundancy. 
These error correction methods take advantage of the subdivision of \gls{cram} into \textit{frames}, each containing information related to the configuration of specific portions of the hardware design \cite{vipin2018dpr}.

\subsection{Fault Injection as an Evaluation Methodology}
Fault injection is widely employed to test and validate fault-tolerant \gls{fpga} designs. By introducing controlled errors in either simulation or hardware, researchers can characterize system behavior under fault conditions. This section examines different fault injection techniques, such as software-based, emulation-based, and on-chip implementations, as well as their relevance for reliability assessment.

Fault Injection (FI) is an established experimental method defined as the deliberate introduction of faults within a system, aiming primarily to evaluate its dependability, reliability, and to validate fault-tolerance mechanisms (FTMs). 
This methodology allows designers to systematically analyze the system’s behavior in the presence of anomalies, 
estimate its failure rate, and determine whether the implemented FTMs fulfill design specifications. 
FI is crucial for qualifying systems, particularly those designed for safety-critical applications such as aerospace, 
where components are susceptible to \textit{Single Event Effects (SEEs)}.

A complete fault injection methodology is comprehensively characterized by four key components:
\begin{enumerate}
    \item The adopted \textbf{fault model};
    \item The \textbf{activation patterns} (stimuli or workload) used to test the design;
    \item The \textbf{readout values} collected during the experiment;
    \item The derived \textbf{metrics}, such as error or failure rate.
\end{enumerate}

Fault models typically represent malfunctions such as transient or permanent faults, 
often modeling \textit{Single Event Upsets (SEUs)} as bit-flips in memory elements. 
To evaluate correctness, the system output is compared against the expected output of a fault-free version, 
commonly referred to as the \textit{golden system} or \textit{golden run}. 
The results collected enable the classification of fault effects into categories such as:
\begin{itemize}
    \item \textbf{Failure} – the system produces incorrect or unexpected behavior;
    \item \textbf{Latent error} – the fault does not immediately affect functionality but may propagate later;
    \item \textbf{Non-effective (benign) fault} – the fault produces no observable effect.
\end{itemize}

\subsubsection{Fault Injection Techniques}

Fault injection techniques are typically classified into three major categories: 
\textbf{physical}, \textbf{simulation-based}, and \textbf{emulation-based} methods.

\begin{enumerate}
    \item \textbf{Physical Fault Injection:}
    This method (e.g., heavy-ion or proton testing) disturbs the actual hardware using environmental factors. 
    It provides high accuracy for real faults but suffers from high cost, limited controllability, 
    and restricted access to internal nodes.

    \item \textbf{Simulation-based Fault Injection:}
    This approach employs high-level models, often described in Hardware Description Languages (HDLs) such as VHDL or Verilog, 
    to reproduce faults in a software environment. 
    It is invaluable during early design phases because it provides high observability and controllability. 
    Common techniques include:
    \begin{itemize}
        \item \textit{Simulator commands}, 
        \item \textit{Saboteurs} – additional components that intercept and alter signals,
        \item \textit{Mutants} – modified versions of existing components.
    \end{itemize}
    However, simulation can become prohibitively slow when evaluating complex systems or conducting large fault campaigns.

    \item \textbf{Emulation-based Fault Injection:}
    This method leverages reconfigurable devices, primarily SRAM-based FPGAs, 
    to perform rapid prototyping and fault injection at run-time. 
    It often involves manipulating the configuration memory (CRAM) 
    through mechanisms such as \textit{Dynamic Partial Reconfiguration (DPR)} 
    or by accessing internal configuration ports (e.g., \textit{ICAP} or \textit{JTAG}) to emulate SEUs. 
    Emulation offers significantly faster evaluation—potentially orders of magnitude faster than simulation—while maintaining 
    greater control than physical testing, making it a preferable choice for high-volume fault injection campaigns 
    aimed at achieving comprehensive fault coverage efficiently.
\end{enumerate}

\section{Summary of Related Works}
This section consolidates previous research in the field of \gls{fpga} reliability enhancement, highlighting key trends, open challenges, and gaps that motivate this dissertation. A comparative analysis of state-of-the-art methods provides the basis for defining the novel contributions of this work.

%%TODO:: Separar 10 papers nesta tabela!!

\begin{table}[htbp]
\centering
\caption{Comparison of \gls{fpga} fault-tolerance approaches in related works}
\label{tab:related_works}
\begin{tabular}{|p{3cm}|p{2.5cm}|p{3cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Reference / Approach} 
& \textbf{Fault-Tolerance Method} 
& \textbf{Evaluation Method} 
& \textbf{Advantages} 
& \textbf{Limitations} \\
\hline
\cite{Barbosa2021}
& Triple Modular Redundancy (TMR) 
& Simulation-based fault injection 
& Simple design, high coverage 
& High area and power overhead \\
\hline
\cite{Adria2023} 
& Dynamic Partial Reconfiguration (DPR) repair 
& On-chip fault injection 
& Real-time reconfiguration, reduced downtime 
& Complex controller, reconfiguration latency \\
\hline
Lee et al. (2019) 
& N-Modular Redundancy (NMR) voter circuits 
& Emulation with fault injection 
& Scalable reliability, configurable protection 
& Significant resource usage for large N \\
\hline
\textbf{This Work} 
& NMR with DPR and integrated fault injection 
& On-chip + software-in-the-loop evaluation 
& Low downtime, tunable redundancy, adaptive repair 
& Slightly higher design complexity \\
\hline
\end{tabular}
\end{table}