%\section{Development Methodology}
\label{sec:cap4}

This chapter details the methodology adopted to design, implement and validate the proposed fault-tolerance approach. Describes the workflow, design tools, experimental setup, and evaluation strategies applied throughout development.

For easier development and debugging, the entire design was broken down into modules and developed independently before integrating it all together into one final architecture. For this, each mitigation was developed and tested independently and, ultimately, all mitigations were implemented in a final solution with a \gls{tmr} \gls{riscv} 32I.

\section{FPGA Platform and Toolchain}
\label{sec:cap4-material}
This section presents the selected \gls{fpga} device, development board, and software toolchain. The hardware platform was chosen considering resource availability, partial dynamic reconfiguration capabilities, and compatibility with on-chip fault injection tools. The toolchain description includes synthesis tools, placement-and-routing strategies, and configuration methods.

\begin{table}[ht]
\centering
\begin{adjustbox}{max width=\paperwidth}
\begin{tabular}{|l|p{11.5cm}|}
\hline
\textbf{Tool} & \textbf{Description} \\
\hline
\href{https://www.xilinx.com/products/design-tools/vivado.html}{Vivado 2018.3} &
Xilinx \gls{fpga} design suite used for \gls{hdl} synthesis, implementation, and bitstream generation. Provides Tcl scripting support for automation. \\
\hline
\href{https://www.python.org/}{Python} &
High-level programming language for automation, scripting, and testbench development. Widely used to coordinate \gls{fpga} workflows and fault injection experiments. \\
\hline
\href{https://github.com/riscv-collab/riscv-gnu-toolchain}{RISC-V Toolchain} &
Open-source GNU toolchain supporting the RISC-V ISA, enabling firmware compilation and debugging for soft-core processors like PicoRV32 \cite{PICORV32I}. \\
\hline
\href{https://github.com/YosysHQ/picorv32/}{PicoRV32} &
Compact and configurable RISC-V soft processor core optimized for \gls{fpga}, often used for embedded control, monitoring, and fault injection control logic. \\
\hline
\end{tabular}
\end{adjustbox}
\caption{Software development tools used in this work.}
\label{tab:sw-tools}
\end{table}

All software resources applied in this work are presented in Table \ref{tab:sw-tools}. The development environment was based on the \href{https://releases.ubuntu.com/18.04/} {Linux Ubuntu 18.04} operating system, which provided stability and compatibility with the required tools.

\begin{table}[ht]
\centering
\begin{adjustbox}{max width=\paperwidth}
\begin{tabular}{|l|p{13.5cm}|}
\hline
\textbf{Tool} & \textbf{Description} \\
\hline
\href{https://www.amd.com/en/corporate/university-program/aup-boards/pynq-z2.html}{Pynq Z2} &
The PYNQ-Z2 is a development board designed for experimenting with FPGAs and embedded systems in an accessible way. It is based on the Xilinx Zynq-7000 SoC (System on Chip). Specifically the Zynq XC7Z020, the same device used in the \href{https://www.amd.com/en/search/partner/embedded-partner-solutions.html#/6821}{Zedboard} development kit. \\
\hline
\href{https://ftdichip.com/products/ft2232hq/}{FT2232} &
The FT2232 is a USB-to-multi-purpose communication interface IC developed by FTDI (Future Technology Devices International).
It is widely used for bridging USB connections to various serial and parallel protocols, making it especially popular in \gls{fpga} development boards, embedded systems, and debugging tools. \\
\hline
\end{tabular}
\end{adjustbox}
\caption{Hardware development tools used in this work.}
\label{tab:hw-tools}
\end{table}

\section{Reference Design Architecture}
In order to evaluate all necessary knowledge to implement the final solution, the first step was to develop an initial architecture with the needed components.

The requirements for this architecture were established on the basis of the following key assumptions:

\begin{itemize}
    \item \textbf{Configuration Memory Scrubbing (CRAM Scrubbing):}  
    Periodic correction of configuration memory upsets to maintain system integrity and prevent fault accumulation.

    \item \textbf{Dynamic Partial Reconfiguration (DPR):}  
    Ability to reconfigure specific regions of the \gls{fpga} at runtime without interrupting the operation of the static logic.

    \item \textbf{Fault Injection Capability:}  
    Implementation of controlled fault injection mechanisms to evaluate the system’s fault tolerance and recovery strategies.
\end{itemize}

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{Cap4/architecture.png}
    \caption{Block diagram representation of the proposed platform.}
    \label{zynq-paper-arch}
\end{figure}

As illustrated  in Figure~\ref{zynq-paper-arch}, the core of the architecture is the Xilinx Zynq-7000, a \gls{soc} integrating a dual-core ARM A9 processor with an \gls{fpga} fabric on the same die.

\subsection{Soft Error Mitigation}
To protect \gls{sram}-based \gls{fpga}, Xilinx’s \gls{sem} \gls{ip}, \cite{amd2023sem} is being used on this platform. The controller can be accessed from a serial console and provides the status of the configuration memory, injection of errors and operational status.

It is possible to communicate with the controller using the AXI Bus of the processor, but for this study an external UART was attached to the design, providing an easy way to use an external PC with a script to inject error and check how the platform behaves.

\subsection{Dynamic Partial Reconfiguration}
Dynamic partial reconfiguration is performed through the ARM´s \gls{pcap} port.
The full or partial bitstream could be loaded from an external memory, for example, the ARM processor's \gls{ddr} memory or SD-Card. With the bitstream stored in the \gls{ddr}, the file is transferred to the PL configuration memory using the \gls{pcap} port using \gls{dma}. This setup frees the processor, and the bitstream is directly loadde into the \gls{fpga} \gls{cram} without processing interruption.

The main idea of the \gls{dpr} region, denoted by the \emph{"HW Accel."} in Figure~\ref{zynq-paper-arch}, is to perform any kind of hardware acceleration needed by the application, being able to reprogram this area accordingly to the need circuit or function needed at that time, giving the system some sort of hardware redundancy in time.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\textwidth]{Cap4/dpr-partial-bit.png}
    \caption{Representation of the "Partial" Bitstreams, responsible for only a small change in \gls{fpga} configuration.}
    \label{dpr-partial-diagram}
\end{figure}

As illustrated in Figure~\ref{dpr-partial-diagram}, it is possible to create any combination of partial bitstreams that could have different functions, for example a multiplier, an adder, a filter or any other needed function. Then, this could be dynamically programmed in this area, changing the behavior of the system without affecting the other function around it.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\textwidth]{Cap4/dpr-full-bit.png}
    \caption{Representation of the "Full" Bitstream, responsible for the entire \gls{fpga} configuration.}
    \label{dpr-full-diagram}
\end{figure}

As illustrated in Figure~\ref{dpr-full-diagram}, the full bitstream reconfigures the entire \gls{fpga} \gls{cram}, so the entire circuit needs to be shut off and will only return to function when the complete reprogram is complete.

The size of the bitstreams, illustrated by the squares in Figures ~\ref{dpr-full-diagram} and~\ref{dpr-partial-diagram}, gives the exact notion of the time needed to reprogram \gls{fpga} \gls{cram}. As the partial bitstream only reprograms a small portion of the device, the full bitstream will reprogram the entire device. So, this translates into the difference in the size of files and the time needed for reconfiguration. 

\subsection{Integration of \glsentrytext{dpr} and \glsentrytext{sem} in the same project}

As defined in \textcite{Xilinx_DS190},the processor sub-system, present in  Zynq device family, has control, at power-up, of all configurations to \gls{pl}, using the \gls{pcap} port. The system is designed this way mainly because of the following facts:
\begin{itemize}
    \item Improvement in the overall security of the design, as the Arm's TrustZone shall take control of the configuration port and, using its set of registers, allow only the non-secure fabric \gls{icap} port to configure the device.
    \item Allows the \gls{fpga} to be configured at boot time, through Arm's \gls{fsbl}.
\end{itemize}

The selection of the interface under control of the \gls{fpga} configuration is made using a 2:1 mux, controlled by the \texttt{PCAP\_PR} register, as illustrated  in Figure~\ref{fig:fpga_mux}.

\begin{figure}[ht!]
    \centering
    \includegraphics[width=1\textwidth]{Cap4/cram.png}
    \caption{2:1 mux controlling the \gls{fpga} configuration interface between \gls{pcap} and \gls{icap}.}
    \label{fig:fpga_mux}
\end{figure}

After initial configuration (or at any time), the processor may set the control bit to switch the configuration interface to be accessed internally to the \gls{fpga} fabric; then \gls{icap} becomes active.

As illustrated  in Figure~\ref{fig:fpga_mux}, the SEM controller uses the port \gls{icap} to perform the scrubbing \gls{cram}. So, after the initial configuration, the processor should release \gls{pcap} and pass the control to \gls{icap}, allowing the SEM controller to monitor, detect, and correct radiation-induced errors.

If the processor needs a partial reconfiguration in some area within the fabric, it will need the \gls{pcap} control back.

When using the SEM Controller, this action is not as simple as changing the mux~\cite{Ayer_XAPP517_2011,Xilinx_ICAP_PCAP_2016,Xilinx_XAPP517} configuration. The following actions should take place \cite{ZanoneSaotome2023}:
\begin{itemize}
    \item Set \gls{sem} \gls{ip} in IDLE mode.
    \item Send an SYNC command, stopping the \gls{sem} \gls{ip} frame’s error scanning.
    \item Select the port \gls{pcap} and perform a dynamic partial reconfiguration.
    \item After the \gls{dpr} operation is done, transfer the control of \gls{icap} back to SEM IP.
    \item Perform a soft reset on \gls{sem} \gls{ip}.
    \item Set \gls{sem} \gls{ip} in \texttt{OBSERVATION} mode.
\end{itemize}

Figure~\ref{fig:fpga_mux} shows the interfaces that were developed to decouple the \gls{sem} \gls{ip} from the \gls{icap}, switching the control to \gls{pcap} to perform the partial reconfiguration. The items highlighted in yellow allow steps 2 and 4 of the procedure to be correctly executed.

To stop \gls{sem} \gls{ip} scanning, the controller should be configured in IDLE mode, and a SYNC word command should be sent through the mux to \gls{icap}. This is accomplished using the output of the \texttt{\gls{icap} Sync controller} block that sends the value \texttt{0x5599AA66}.

When \gls{dpr} is finished, \gls{pcap} can switch the control back to the \gls{sem} controller. This is accomplished by commanding the \texttt{value of icap\_sel} and setting the mux to connect \gls{sem} \gls{ip} to \gls{icap}.

After a partial reconfiguration is performed, before \gls{sem} \gls{ip} returns to the observation mode, it is necessary to perform a soft reset in the controller, recalculating the FRAME \gls{ecc} of \gls{cram}. If \gls{sem} \gls{ip} is commanded back to observation mode without soft reset, the controller will detect reconfiguration as \glspl{seu} and will try to correct them.

If \gls{sem} \gls{ip} is not changed to IDLE mode prior to \gls{dpr}, it will continue in observation mode; then, during partial reconfiguration, the changes in \gls{cram} will be interpreted as \gls{seu}s. The \gls{sem} \gls{ip} will try to correct those bit flips, potentially entering a loop of error correction and reconfiguration, resulting in a failed reprogramming of the area.

It is important that all \gls{pcap} or \gls{icap} operations are completed before switching control between them. Figure~\ref{fig:fpga_mux} also shows that JTAG has precedence over both ports, so care should be taken when using JTAG together with \gls{pcap} and \gls{icap} to avoid interference between the ports.

\section{Implementation of N-Modular Redundancy}
In this section, the integration of the NMR scheme is detailed. The voter architecture, module replication strategy, and resource allocation are discussed. Specific design trade-offs such as latency, area overhead, and power consumption are analyzed to justify the parameters chosen for $N>3$.

In this work, both \gls{dmr} and \gls{tmr} architectures were implemented and subjected to fault injection experiments to assess their fault-masking behavior and validate the proposed evaluation framework. The fault injection process was used to introduce controlled upsets into the redundant modules, allowing analysis of how each redundancy scheme reacts to injected faults under similar test conditions.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Cap4/fir-dmr.png}
    \caption{Block diagram representation of the proposed Duplicated \gls{fir} filters.}
    \label{fig:fir-dmr}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Cap4/dut_fir_bird_view.png}
    \caption{Block diagram representation for the Vivado implementation, showing the \gls{fir} filter implemented in the \textit{My Design} block and the \gls{sem} wrapper containing the scrubber, which integrates the \gls{semip} and the ARM processor.}
    \label{fig:dut_fir_bird_view}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Cap4/detail_fir.png}
    \caption{Block Diagram, in detail, of the \gls{fir} implementation in Vivado. The \gls{dmr} is presented and the circuit to detect if the modules has the correct outputs.}
    \label{fig:detail_fir}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{Cap4/riscv-tmr-diagram.png}
    \caption{Block diagram representation of the proposed Triplicated PicoRV32I.}
    \label{riscv-tmr-diagram}
\end{figure}

As illustrated  in Figure~\ref{fig:fir-dmr},

As illustrated  in Figure~\ref{riscv-tmr-diagram},

As illustrated  in Figure~\ref{fig:dut_fir_bird_view},

As illustrated  in Figure~\ref{fig:detail_fir},

\begin{landscape}
    \begin{figure}[ht]
    \centering
    \includegraphics[width=1.5\textwidth]{Cap4/tmr-vivado.png}
    \caption{Block Diagram of the implementation in Vivado. In the blue square (left) the memory for the \gls{riscv} instructions (firmware), in the red square (center) the triplicated \gls{riscv} cores and in the black square (right) the word voters inserted in each output of the PicoRV32 RISC-V core.}\label{vivado-tmr}
\end{figure}\end{landscape}

It is essential, when designing systems based on modular redundancy, to carefully analyze the synthesis and implementation logs generated by the design tool---in this work, Vivado---to ensure that redundant modules are not optimized away.

Since modular redundancy typically employs multiple identical instances of a module operating in parallel and receiving identical input signals, as illustrated in Figure~\ref{riscv-tmr-diagram}, the synthesis tool can infer functional equivalence between them. Consequently, since these modules generate the same output, the tool might remove one or more instances during optimization.

In Vivado, one message that may indicate such an optimization is the following:

\begin{verbatim}
[Synth 8-223] decloning instance <name> to <name>
\end{verbatim}

This message indicates that the tool has merged or eliminated redundant module instances (``clones''), which may compromise the intended fault-tolerant behavior of the design.

As presented by \textcite{acmeTuto}, one possible solution to this issue is the inclusion of the attribute \texttt{dont\_touch} in the design. This attribute is recognized by the synthesis tool and propagated to the place-and-route stages, ensuring that the specified object is preserved and not subject to optimization \cite{AMD:KEEP_DONT_TOUCH}.

The following examples illustrate how to apply this attribute in different design description contexts:

\begin{itemize}
    \item \textbf{\gls{tcl} Script (Vivado Constraint):}
    \begin{verbatim}
    set_property DONT_TOUCH true [get_cells <module_name>]
    \end{verbatim}

    \item \textbf{Verilog:}
    \begin{verbatim}
    (* DONT_TOUCH = "true" *) module <module_name> (...);
    endmodule
    \end{verbatim}

    \item \textbf{\gls{vhdl}:}
    \begin{verbatim}
    attribute DONT_TOUCH : string;
    attribute DONT_TOUCH of <entity_name> : entity is "true";
    \end{verbatim}
\end{itemize}

Another configuration applied to both architectures was the disabling of the \gls{dsp}48 blocks in the \gls{fpga}. This ensured that the design was implemented exclusively using \glspl{lut}, which made the \gls{fi} process more consistent and easier to emulate.

\begin{itemize}
    \item \textbf{\gls{tcl} Script (Vivado Constraint):}
    \begin{verbatim}
    set_property USE_DSP48 no [get_cells <module_name>]
    \end{verbatim}
\end{itemize}

\section{Partial Dynamic Reconfiguration Flow}
The implementation of partial dynamic reconfiguration is explained, focusing on how faulty modules can be repaired in real time without halting system operation. This includes the generation of partial bitstreams, the design of the reconfiguration controller, and performance metrics such as reconfiguration latency and system recovery time.

\gls{dpr} flow is supported by Vivado, but is not yet fully integrated with the GUI-based project flow~\cite{vipin2018dpr}. 
The designs are implemented using the Vivado \gls{tcl}-based command flow or a combination of \gls{tcl} commands and the GUI. 
To facilitate the reproduction of the results and provide a base configuration for other studies using this architecture, a set of scripts was developed to create a project with two PR modules, implementing the following steps:

\begin{itemize}
    \item Create the project and block design.
    \begin{itemize}
        \item The block design should contain the ARM processing system instance.
        \item The reconfigurable items should have only the interface definitions declared in this step.
    \end{itemize}
    \item Synthesize the design, generating all the design checkpoints (DCP) for the static region and blocks of logic.
    \item Load the \gls{dcp} for the static region and one of the reconfigurable partitions (RP).
    \item Define RP properties.
    \item Run Design Rule Checker (DRC).
    \item Create and implement the first configuration.
    \begin{itemize}
        \item  It is important that all the configurable resources (\glspl{lut}, \glspl{ff}, \glspl{bram}, \glspl{dsp}) needed by the design must be available in the allocated space for the partial area.
    \end{itemize}
    \item Create all other configurations.
    \item Verify all configurations using the \texttt{PR\_verify} command.
    \item Generate bitstreams.
\end{itemize}

The \gls{dpr} process is carried out through the ARM \gls{pcap} interface. Initially, the full or partial bitstream is stored in the processor’s \gls{ddr} memory, after which a \gls{dma} transfer sends it to the configuration memory of the programmable logic (PL) via the \gls{pcap} port.

\begin{landscape}
    \begin{figure}[ht]
    \centering
    \includegraphics[width=1.5\textwidth]{Cap4/pr_math_bd.png}
    \caption{Block Diagram of the implementation in Vivado. In the blue square (center) the area for \gls{dpr} of the mathematical function (multiplier or adder), in the red square (left) the check box indicating that this is a \gls{pr} block in the violet square (right) the \gls{pr} decoupler for the \gls{axi} bus.}\label{vivado-pr-math}
\end{figure}\end{landscape}

\section{Integration with Processing System (PS)}
This section discusses how the ARM processing system in the \gls{soc} was used to monitor and control the fault-tolerant logic. Mitigation strategies were partially moved to the PS side to balance the workload and reduce logic overhead in the programmable fabric.

\section{Fault Injection Strategy}
This subsection describes how faults were emulated in the \gls{fpga} to validate system robustness. Both hardware-based and software-assisted fault injection approaches are explained, along with fault models (single-event upsets, multiple-bit upsets) and their mapping to the \gls{fpga} fabric. The methodology ensures repeatability and coverage of critical failure modes.

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{Cap4/error_injection.png}
    \caption{Block diagram representation the error injection campaign and setup.}
    \label{error-injection-diagram}
\end{figure}

As illustrated  in Figure~\ref{error-injection-diagram},

As explained in Section~\ref{sec:cap3}, the configuration memory is distributed throughout the \gls{fpga}, defining the functionality of its internal resources, including the \glspl{clb}, \glspl{bram}, \glspl{dsp}, and routing interconnections. This memory is organized into frames arranged in rows and columns corresponding to specific configurable resources, with multiple frames per column forming clock regions within the device. To perform \gls{fi}, it is necessary to identify and extract the frame addresses, along with the words and bits within those frames, that correspond to the \gls{dut} \cite{Garcia2020}.

For this purpose, Xilinx provides the \textit{Essential Bits} technology~\cite{Garcia2020,Yang2022_FaultInjectionUltrascale}, which generates, along with the bitstream, a mask file indicating whether each configuration bit is used in the design. This information is stored in the \texttt{.ebd} file. To enable the generation of the \gls{ebd} file, the following constraint must be added to the Vivado project:

\begin{itemize}
    \item \textbf{\gls{tcl} Script (Vivado Constraint):}
    \begin{verbatim}
set_property BITSTREAM.SEU.ESSENTIALBITS YES [current_design]
    \end{verbatim}
\end{itemize}

The mapping between the \gls{ebd} file and the configuration memory enables the identification of configuration bits that are essential for the implemented design. This mapping provides a practical foundation for correlating the logical elements defined during synthesis with their physical representation in the \gls{fpga} configuration frames, thereby allowing precise targeting of configuration bits during \gls{fi} experiments.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Cap4/xilinx-ebd-ebc.png}
        \caption{Final implementation report from Xilinx, showing how many critical bits the solution has and \gls{ebd} and \gls{ebc} files in detail.}
    \label{fig:xilinx-ebd-ebc}
\end{figure}

As illustrated  in Figure~\ref{fig:xilinx-ebd-ebc},

\section{Verification and Validation Methodology}
The testing strategy is presented to demonstrate how the design was verified at the simulation level, the emulation level, and on physical \gls{fpga} hardware. Metrics such as fault coverage, error latency, and resource usage were systematically measured to evaluate the effectiveness of the proposed solution.

\section{Summary}
This section summarizes the methodology chapter, highlighting the major design decisions and how they lay the groundwork for the results presented in the next chapter.

These added capabilities make the platform suitable for deployment in harsh environments, particularly for non-critical instrumentation and communication systems, as \gls{sram}-based \glspl{fpga} provide a cost- and area-efficient solution \cite{Brosser2014}.
