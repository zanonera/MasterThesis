%\section{Development Methodology}
\label{sec:cap4}

This chapter details the methodology adopted to design, implement and validate the proposed fault-tolerance approach. Describes the workflow, design tools, experimental setup, and evaluation strategies applied throughout development.

For easier development and debugging, the entire design was broken down into modules and developed independently before integrating it all together into one final architecture. For this, each mitigation was developed and tested independently and, ultimately, all mitigations were implemented in a final solution with a \gls{tmr} \gls{riscv} 32I.

\section{FPGA Platform and Toolchain}
This section presents the selected FPGA device, development board, and software toolchain. The hardware platform was chosen considering resource availability, partial dynamic reconfiguration capabilities, and compatibility with on-chip fault injection tools. The toolchain description includes synthesis tools, placement-and-routing strategies, and configuration methods.

\begin{table}[ht]
\centering
\begin{adjustbox}{max width=\paperwidth}
\begin{tabular}{|l|p{11.5cm}|}
\hline
\textbf{Tool} & \textbf{Description} \\
\hline
\href{https://www.xilinx.com/products/design-tools/vivado.html}{Vivado 2018.3} &
Xilinx FPGA design suite used for HDL synthesis, implementation, and bitstream generation. Provides Tcl scripting support for automation. \\
\hline
\href{https://www.python.org/}{Python} &
High-level programming language for automation, scripting, and testbench development. Widely used to coordinate FPGA workflows and fault injection experiments. \\
\hline
\href{https://github.com/riscv-collab/riscv-gnu-toolchain}{RISC-V Toolchain} &
Open-source GNU toolchain supporting the RISC-V ISA, enabling firmware compilation and debugging for soft-core processors like PicoRV32 \cite{PICORV32I}. \\
\hline
\href{https://github.com/YosysHQ/picorv32/}{PicoRV32} &
Compact and configurable RISC-V soft processor core optimized for FPGA, often used for embedded control, monitoring, and fault injection control logic. \\
\hline
\end{tabular}
\end{adjustbox}
\caption{Software development tools used in this work.}
\label{tab:sw-tools}
\end{table}

All software resources applied in this work are presented in Table \ref{tab:sw-tools}. The development environment was based on the \href{https://releases.ubuntu.com/18.04/} {Linux Ubuntu 18.04} operating system, which provided stability and compatibility with the required tools.

\begin{table}[ht]
\centering
\begin{adjustbox}{max width=\paperwidth}
\begin{tabular}{|l|p{13.5cm}|}
\hline
\textbf{Tool} & \textbf{Description} \\
\hline
\href{https://www.amd.com/en/corporate/university-program/aup-boards/pynq-z2.html}{Pynq Z2} &
The PYNQ-Z2 is a development board designed for experimenting with FPGAs and embedded systems in an accessible way. It is based on the Xilinx Zynq-7000 SoC (System on Chip). Specifically the Zynq XC7Z020, the same device used in the famous \href{https://www.amd.com/en/search/partner/embedded-partner-solutions.html#/6821}{Zedboard}. \\
\hline
\href{https://ftdichip.com/products/ft2232hq/}{FT2232} &
The FT2232 is a USB-to-multi-purpose communication interface IC developed by FTDI (Future Technology Devices International).
It is widely used for bridging USB connections to various serial and parallel protocols, making it especially popular in FPGA development boards, embedded systems, and debugging tools. \\
\hline
\end{tabular}
\end{adjustbox}
\caption{Hardware development tools used in this work.}
\label{tab:hw-tools}
\end{table}

\section{Reference Design Architecture}
In order to evaluate all necessary knowledge to implement the final solution, the first step was to develop an initial architecture with the needed components.

The requirements for this architecture were established on the basis of the following key assumptions:

\begin{itemize}
    \item \textbf{Configuration Memory Scrubbing (CRAM Scrubbing):}  
    Periodic correction of configuration memory upsets to maintain system integrity and prevent fault accumulation.

    \item \textbf{Dynamic Partial Reconfiguration (DPR):}  
    Ability to reconfigure specific regions of the FPGA at runtime without interrupting the operation of the static logic.

    \item \textbf{Fault Injection Capability:}  
    Implementation of controlled fault injection mechanisms to evaluate the system’s fault tolerance and recovery strategies.
\end{itemize}

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{Cap4/architecture.png}
    \caption{Block diagram representation of the proposed platform.}
    \label{zynq-paper-arch}
\end{figure}

As shown in Figure~\ref{zynq-paper-arch}, the core of the architecture is the Xilinx Zynq-7000, a \gls{soc} integrating a dual-core ARM A9 processor with an \gls{fpga} fabric on the same die.

\subsection{Soft Error Mitigation}
To protect \gls{sram}-based FPGA, Xilinx’s \gls{sem} \gls{ip}, \cite{amd2023sem} is being used on this platform. The controller can be accessed from a serial console and provides the status of the configuration memory, injection of errors and operational status.
It is possible to communicate with the controller using the AXI Bus of the processor, but for this study an external UART was attached to the design, providing an easy way to use an external PC with a script to inject error and check how the platform behaves.

\subsection{Dynamic Partial Reconfiguration}
Dynamic partial reconfiguration is performed through the ARM´s \gls{pcap} port.
The full or partial bitstream is loaded to the processor \gls{ddr}, then using \gls{dma}, the file is transferred to the configuration memory of the PL using the \gls{pcap} port.

The main idea of the \gls{dpr} region, denoted by the "HW Accel." in Figure~\ref{zynq-paper-arch}, is to perform any kind of hardware acceleration needed by the application and to be able to reprogram this function accordingly to the one necessary for that specify computation.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\textwidth]{Cap4/dpr-partial-bit.png}
    \caption{Representation of the "Partial" Bitstreams, responsible for only a small change in \gls{fpga} configuration.}
    \label{dpr-partial-diagram}
\end{figure}

As shown in Figure~\ref{dpr-partial-diagram},

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\textwidth]{Cap4/dpr-full-bit.png}
    \caption{Representation of the "Full" Bitstream, responsible for the entire FPGA configuration.}
    \label{dpr-full-diagram}
\end{figure}

As shown in Figure~\ref{dpr-full-diagram},

\subsection{Integration of \glsentrytext{dpr} and \glsentrytext{sem} in the same project}

In Zynq~\cite{Xilinx_DS190}, the processor sub-system has control at power-up of all configurations to \gls{pl}, using the \gls{pcap} port. The system is designed this way mainly because of two factors: 
\begin{enumerate}
    \item Improve the overall security of the design, so the Arm's TrustZone should take control of the configuration port and, using its set of registers, allow only the non-secure fabric \gls{icap} port to configure the device.
    \item Allowing \gls{fpga}' configuration at boot time through Arm's \gls{fsbl}.
\end{enumerate}

The selection of the interface under control of the \gls{fpga} configuration is made using a 2:1 mux, controlled by the \texttt{PCAP\_PR} register, as shown in Figure~\ref{fig:fpga_mux}.

\begin{figure}[ht!]
    \centering
    \includegraphics[width=1\textwidth]{Cap4/cram.png}
    \caption{2:1 mux controlling the FPGA configuration interface between \gls{pcap} and \gls{icap}.}
    \label{fig:fpga_mux}
\end{figure}

After initial configuration (or at any time), the processor may set the control bit to switch the configuration interface to be accessed internally to the FPGA fabric; then \gls{icap} becomes active.

As shown in Figure~\ref{fig:fpga_mux}, the SEM controller uses the port \gls{icap} to perform the scrubbing \gls{cram}. So, after the initial configuration, the processor should release \gls{pcap} and pass the control to \gls{icap}, allowing the SEM controller to monitor, detect, and correct radiation-induced errors.

If the processor needs a partial reconfiguration in some area within the fabric, it will need the \gls{pcap} control back.

When using the SEM Controller, this action is not as simple as changing the mux~\cite{Ayer_XAPP517_2011,Xilinx_ICAP_PCAP_2016,Xilinx_XAPP517} configuration. The following actions should take place \cite{ZanoneSaotome2023}:
\begin{enumerate}
    \item Set \gls{sem} \gls{ip} in IDLE mode.
    \item Send an SYNC command, stopping the \gls{sem} \gls{ip} frame’s error scanning.
    \item Select the port \gls{pcap} and perform a dynamic partial reconfiguration.
    \item After the DPR operation is done, transfer the control of \gls{icap} back to SEM IP.
    \item Perform a soft reset on \gls{sem} \gls{ip}.
    \item Set \gls{sem} \gls{ip} in \texttt{OBSERVATION} mode.
\end{enumerate}

Figure~\ref{fig:fpga_mux} shows the interfaces that were developed to decouple the \gls{sem} \gls{ip} from the \gls{icap}, switching the control to \gls{pcap} to perform the partial reconfiguration. The items highlighted in yellow allow steps 2 and 4 of the procedure to be correctly executed.

To stop \gls{sem} \gls{ip} scanning, the controller should be configured in IDLE mode, and a SYNC word command should be sent through the mux to \gls{icap}. This is accomplished using the output of the \texttt{\gls{icap} Sync controller} block that sends the value \texttt{0x5599AA66}.

When \gls{dpr} is finished, \gls{pcap} can switch the control back to the \gls{sem} controller. This is accomplished by commanding the \texttt{value of icap\_sel} and setting the mux to connect \gls{sem} \gls{ip} to \gls{icap}.

After a partial reconfiguration is performed, before \gls{sem} \gls{ip} returns to the observation mode, it is necessary to perform a soft reset in the controller, recalculating the FRAME \gls{ecc} of \gls{cram}. If \gls{sem} \gls{ip} is commanded back to observation mode without soft reset, the controller will detect reconfiguration as \glspl{seu} and will try to correct them.

If \gls{sem} \gls{ip} is not changed to IDLE mode prior to \gls{dpr}, it will continue in observation mode; then, during partial reconfiguration, the changes in \gls{cram} will be interpreted as \gls{seu}s. The \gls{sem} \gls{ip} will try to correct those bit flips, potentially entering a loop of error correction and reconfiguration, resulting in a failed reprogramming of the area.

It is important that all \gls{pcap} or \gls{icap} operations are completed before switching control between them. Figure~\ref{fig:fpga_mux} also shows that JTAG has precedence over both ports, so care should be taken when using JTAG together with \gls{pcap} and \gls{icap} to avoid interference between the ports.

\section{Implementation of N-Modular Redundancy}
Here, the integration of the NMR scheme is detailed. The voter architecture, module replication strategy, and resource allocation are discussed. Specific design trade-offs such as latency, area overhead, and power consumption are analyzed to justify the chosen parameters for $N>3$.

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{Cap4/riscv-tmr-diagram.png}
    \caption{Block diagram representation of the proposed Triplicated PicoRV32I.}
    \label{riscv-tmr-diagram}
\end{figure}

As shown in Figure~\ref{riscv-tmr-diagram},

\begin{landscape}
    \begin{figure}[ht]
    \centering
    \includegraphics[width=1.5\textwidth]{Cap4/tmr-vivado.png}
    \caption{Block Diagram of the implementation in Vivado. In the blue square (left) the memory for the RISC-V instructions (firmware), in the red square (center) the triplicated RISC-V cores and in the black square (right) the word voters inserted in each output of the PicoRV32 RISC-V core.}\label{vivado-tmr}
\end{figure}\end{landscape}

It is essential, when designing systems based on modular redundancy, to carefully analyze the synthesis and implementation logs generated by the design tool---in this work, Vivado---to ensure that redundant modules are not optimized away.

Since modular redundancy typically employs multiple identical instances of a module operating in parallel and receiving identical input signals, as illustrated in Figure~\ref{riscv-tmr-diagram}, the synthesis tool can infer functional equivalence between them. Consequently, as these modules generate the same output, the tool might remove one or more instances during optimization.

In Vivado, one message that may indicate such an optimization is the following:

\begin{verbatim}
[Synth 8-223] decloning instance <name> to <name>
\end{verbatim}

This message indicates that the tool has merged or eliminated redundant module instances (``clones''), which may compromise the intended fault-tolerant behavior of the design.

As presented by \citeauthor{acmeTuto}, one possible solution to this issue is the inclusion of the attribute \texttt{dont\_touch} in the design. This attribute is recognized by the synthesis tool and propagated to the place-and-route stages, ensuring that the specified object is preserved and not subject to optimization \cite{AMD:KEEP_DONT_TOUCH}.

The following examples illustrate how to apply this attribute in different design description contexts:

\begin{itemize}
    \item \textbf{\gls{tcl} Script (Vivado Constraint):}
    \begin{verbatim}
    set_property DONT_TOUCH true [get_cells <module_name>]
    \end{verbatim}

    \item \textbf{Verilog:}
    \begin{verbatim}
    (* DONT_TOUCH = "true" *) module <module_name> (...);
    endmodule
    \end{verbatim}

    \item \textbf{\gls{vhdl}:}
    \begin{verbatim}
    attribute DONT_TOUCH : string;
    attribute DONT_TOUCH of <entity_name> : entity is "true";
    \end{verbatim}
\end{itemize}

\section{Partial Dynamic Reconfiguration Flow}
The implementation of partial dynamic reconfiguration is explained, focusing on how faulty modules can be repaired in real time without halting system operation. This includes the generation of partial bitstreams, the design of the reconfiguration controller, and performance metrics such as reconfiguration latency and system recovery time.

\gls{dpr} flow is supported by Vivado, but is not yet fully integrated with the GUI-based project flow~\cite{vipin2018dpr}. 
The designs are implemented using the Vivado Tcl-based command flow or a combination of Tcl commands and the GUI. 
To facilitate the reproduction of the results and provide a base configuration for other studies using this architecture, a set of scripts was developed to create a project with two PR modules, implementing the following steps:

\begin{enumerate}
    \item Create the project and block design.
    \begin{enumerate}
        \item The block design should contain the ARM processing system instance.
        \item The reconfigurable items should have only the interface definitions declared in this step.
    \end{enumerate}
    \item Synthesize the design, generating all the design checkpoints (DCP) for the static region and blocks of logic.
    \item Load the DCP for the static region and one of the reconfigurable partitions (RP).
    \item Define RP properties.
    \item Run Design Rule Checker (DRC).
    \item Create and implement the first configuration.
    \begin{enumerate}
        \item  It is important that all the configurable resources (LUTs, FFs, BRAMs, DSPs) needed by the design must be available in the allocated space for the partial area.
    \end{enumerate}
    \item Create all other configurations.
    \item Verify all configurations using the \texttt{PR\_verify} command.
    \item Generate bitstreams.
\end{enumerate}

The \gls{dpr} process is carried out through the ARM \gls{pcap} interface. Initially, the full or partial bitstream is stored in the processor’s DDR memory, after which a DMA transfer sends it to the configuration memory of the programmable logic (PL) via the \gls{pcap} port.

\section{Integration with Processing System (PS)}
This section discusses how the ARM processing system in the SoC was used to monitor and control the fault-tolerant logic. Mitigation strategies were partially moved to the PS side to balance workload and reduce logic overhead in the programmable fabric.

\section{Fault Injection Strategy}
This subsection describes how faults were emulated in the FPGA to validate system robustness. Both hardware-based and software-assisted fault injection approaches are explained, along with fault models (single-event upsets, multiple-bit upsets) and their mapping to the FPGA fabric. The methodology ensures repeatability and coverage of critical failure modes.

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{Cap4/error_injection.png}
    \caption{Block diagram representation the error injection campaign and setup.}
    \label{error-injection-diagram}
\end{figure}

As shown in Figure~\ref{error-injection-diagram},

\section{Verification and Validation Methodology}
The testing strategy is presented to demonstrate how the design was verified at simulation level, emulation level, and on the physical FPGA hardware. Metrics such as fault coverage, error latency, and resource usage were systematically measured to evaluate the effectiveness of the proposed solution.

\section{Summary}
This section summarizes the methodology chapter, highlighting the major design decisions and how they lay the groundwork for the results presented in the next chapter.

These added capabilities make the platform suitable for deployment in harsh environments, particularly for non-critical instrumentation and communication systems, as \gls{sram}-based \glspl{fpga} provide a cost- and area-efficient solution \cite{Brosser2014}.
