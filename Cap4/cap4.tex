%\section{Development Methodology}
\label{sec:cap4}

This chapter details the methodology adopted to design, implement and validate the proposed fault-tolerance approach. Describes the workflow, design tools, experimental setup, and evaluation strategies applied throughout development.

For easier development and debugging, the entire design was broken down into modules and developed independently before integrating it all together into one final architecture. For this, each mitigation was developed and tested independently and, ultimately, all mitigations were implemented in a final solution with a \gls{tmr} \gls{riscv} 32I.

\section{FPGA Platform and Toolchain}
\label{sec:cap4-material}
This section presents the selected \gls{fpga} device, development board, and software toolchain. The hardware platform was chosen considering resource availability, \gls{dpr} capabilities, and compatibility with on-chip fault injection tools. The toolchain description includes synthesis tools, placement-and-routing strategies, and configuration methods.

\begin{table}[ht]
\caption{List of \acrlong{sw} development tools employed in this work}
\label{tab:sw-tools}
\centering
\begin{adjustbox}{max width=\paperwidth}
\begin{tabular}{c p{12cm}}
\hline
\textbf{Tool} & \textbf{Description} \\
\hline
\href{https://www.xilinx.com/products/design-tools/vivado.html}{Vivado 2018.3} &
Xilinx \gls{fpga} design suite used for \gls{hdl} synthesis, implementation, and bitstream generation. Provides Tcl scripting support for automation. \\

\href{https://www.python.org/}{Python 3.6.9} &
High-level programming language for automation, scripting, and testbench development. Widely used to coordinate \gls{fpga} workflows and fault injection experiments. \\

\href{https://github.com/riscv-collab/riscv-gnu-toolchain}{RISC-V Toolchain} &
Open-source GNU toolchain supporting the RISC-V ISA, enabling firmware compilation and debugging for soft-core processors like PicoRV32 \cite{PICORV32I}. \\

\href{https://github.com/YosysHQ/picorv32/}{PicoRV32} &
Compact and configurable RISC-V soft processor core optimized for \gls{fpga}, often used for embedded control, monitoring, and fault injection control logic. \\
\hline
\end{tabular}
\end{adjustbox}
\end{table}

Table~\ref{tab:sw-tools} lists the \gls{sw} resources and the \gls{riscv} \textit{soft-core} utilized in this work. The development environment was based on the \href{https://releases.ubuntu.com/18.04/}{Linux Ubuntu 18.04} operating system, which provided stability and compatibility with the required toolchain.

\begin{table}[ht]
\caption{List of \acrlong{hw} development kits employed in this work}
\label{tab:hw-tools}
\centering
\begin{adjustbox}{max width=\paperwidth}
\begin{tabular}{c p{12cm}}
\hline
\textbf{Tool} & \textbf{Description} \\
\hline
\href{https://www.amd.com/en/corporate/university-program/aup-boards/pynq-z2.html}{Pynq Z2} &
The PYNQ-Z2 is a development board designed for experimenting with FPGAs and embedded systems in an accessible way. It is based on the Xilinx Zynq-7000 SoC (System on Chip). Specifically the Zynq XC7Z020, the same device used in the \href{https://www.amd.com/en/search/partner/embedded-partner-solutions.html#/6821}{Zedboard} development kit. \\

\href{https://ftdichip.com/products/ft2232hq/}{FT2232} &
The FT2232 is a USB-to-multi-purpose communication interface IC developed by FTDI (Future Technology Devices International).
It is widely used for bridging USB connections to various serial and parallel protocols, making it especially popular in \gls{fpga} development boards, embedded systems, and debugging tools. \\
\hline
\end{tabular}
\end{adjustbox}
\end{table}

Table~\ref{tab:hw-tools} presents the \gls{hw} development platforms used in this research.

\section{Reference Design Architecture}
\label{sec:ref-design-arch}
To acquire the knowledge necessary to implement the final solution, the first step consisted in developing a preliminary architecture containing all the required components.

The requirements for this architecture were established on the basis of the following key assumptions:

\begin{itemize}
    \item \textbf{\acrlong{ms}:}  
    Periodic correction of configuration memory upsets to maintain system integrity and prevent accumulation of faults.

    \item \textbf{\acrlong{dpr}:}  
    Ability to reconfigure specific regions of \gls{fpga} at runtime without interrupting the operation of the static logic.

    \item \textbf{\acrlong{fi}:}  
    Implementation of controlled fault injection mechanisms to evaluate system fault tolerance and recovery strategies.
\end{itemize}

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{Cap4/architecture.png}
    \caption{Block diagram representation of the proposed fault-tolerant platform, highlighting the integration between the \acrshort{soc} processor, reconfigurable hardware modules, and the supporting infrastructure for \acrshort{fi}, \acrshort{dpr}, and scrubbing operations.}
    \label{zynq-paper-arch}
\end{figure}

As illustrated  in Figure~\ref{zynq-paper-arch}, the core of the architecture is the Xilinx Zynq-7000, a \gls{soc} integrating a dual-core ARM A9 processor with an \gls{fpga} fabric on the same die.

\subsection{Soft Error Mitigation via \acrlong{ms}}
To protect the \gls{sram}-based \gls{fpga}, Xilinx’s \gls{semip}, \cite{amd2023sem} is being used in this platform. The controller can be accessed from a serial console and provides the status of the configuration memory, injection of errors and operational status.

It is possible to communicate with the controller using the AXI Bus of the processor, but for this study an external UART was attached to the design, providing an easy way to use a computer with a script to inject error and check how the platform behaves.

\gls{semip} was selected as the \gls{ms} methodology because it is natively available on the 7-series devices used in this work and supports \gls{fi} within the same \gls{ip}. This approach is classified as an internal scrubbing technique, as it leverages the embedded \gls{ecc} present in each configuration frame of \gls{fpga}, thus eliminating the need for external memory to store the golden bitstream. The \gls{ip} was configured to operate in the readback scrubbing mode.

The readback method was chosen because it provides greater reliability compared to blind scrubbing, as it enables the detection and classification of bits affected by \glspl{see}.

Internal scrubbing was also preferred because it does not require the SelectMAP interface, which is more susceptible to \glspl{seu}. Instead, this type of \gls{ms} utilizes the \gls{pcap} or \gls{icap} interfaces, and both are less vulnerable to \glspl{seu} compared to SelectMAP~\cite{Mousavi2023_MTTR_FPGA_Scrubbing}.

\subsection{Dynamic Partial Reconfiguration}
Dynamic partial reconfiguration is performed through the ARM´s \gls{pcap} port.
The full or partial bitstream can be loaded from an external memory, for example, the ARM processor's \gls{ddr} memory or SD-Card. With the bitstream stored in \gls{ddr}, the file is transferred to the \gls{pl} configuration memory using the \gls{pcap} port using \gls{dma}. This setup frees the processor, and the bitstream is loaded directly into the \gls{fpga} \gls{cram} without processing interruption.

The main idea of the \gls{dpr} region, denoted by the \emph{"HW Accel."} in Figure~\ref{zynq-paper-arch}, is to perform any kind of hardware acceleration needed by the application. It is possible to reprogram this area accordingly to the function needed at a given time, enabling some sort of hardware redundancy over time.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\textwidth]{Cap4/dpr-partial-bit.png}
    \caption{Representation of “partial” bitstreams used in \acrshort{dpr}, which modify only a specific region of the \acrshort{fpga} fabric while preserving the operation of static regions.}
    \label{dpr-partial-diagram}
\end{figure}

As illustrated in Figure~\ref{dpr-partial-diagram}, it is possible to create any combination of partial bitstreams that can have different functions, for example a multiplier, an adder, a filter or any other needed function. Then, this can be dynamically programmed in this area, changing the behavior of the system without affecting the other function around it.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\textwidth]{Cap4/dpr-full-bit.png}
    \caption{Representation of the “full” bitstream, which contains the complete configuration data required to program all regions of the \acrshort{fpga}, including static and reconfigurable areas.}
    \label{dpr-full-diagram}
\end{figure}

As illustrated in Figure~\ref{dpr-full-diagram}, the full bitstream reconfigures the entire \gls{fpga} \gls{cram}, so the entire circuit needs to be shut off and will only return to function when the complete reprogram is complete.

The size of the bitstreams, illustrated by the squares in Figures ~\ref{dpr-partial-diagram} and~\ref{dpr-full-diagram}, gives the exact notion of the time needed to reprogram \gls{fpga}'s \gls{cram}. Partial bitstream only reprograms a small portion of the device and full bitstream will reprogram the entire device. This is directly proportional to the difference in the size of the files and the time needed for reconfiguration.

\subsection{Integration of \glsentrytext{dpr} and \glsentrytext{sem} in the same project}

As defined in \textcite{Xilinx_DS190},the processor sub-system, present in  Zynq device family, has control, at power-up, of all configurations to \gls{pl}, using the \gls{pcap} port. The system is designed this way mainly because of the following facts:
\begin{itemize}
    \item Improvement in the overall security of the design, as the Arm's TrustZone shall take control of the configuration port and, using its set of registers, allow only the non-secure fabric \gls{icap} port to configure the device.
    \item Allows the \gls{fpga} to be configured at boot time, through Arm's \gls{fsbl}.
\end{itemize}

The selection of the interface under control of the \gls{fpga} configuration is made using a 2:1 mux, controlled by the \texttt{PCAP\_PR} register, as illustrated  in Figure~\ref{fig:fpga_mux}.

\begin{figure}[ht!]
    \centering
    \includegraphics[width=1\textwidth]{Cap4/cram.png}
    \caption{Block representation illustrating the data flow and access priorities among the \acrshort{fpga} configuration interfaces, showing how \acrshort{pcap}, \acrshort{icap}, \acrshort{jtag}, and \acrshort{semip} ports interact with the device’s \acrshort{cram}.}
    \label{fig:fpga_mux}
\end{figure}

After initial configuration (or at any time), the processor may set the control bit to switch the configuration interface to be accessed internally to the \gls{fpga} fabric; then \gls{icap} becomes active.

As illustrated  in Figure~\ref{fig:fpga_mux}, the \gls{semip} controller uses the port \gls{icap} to perform the \gls{cram} \gls{ms}. So, after the initial configuration, the processor should release \gls{pcap} and pass the control to \gls{icap}, allowing the \gls{semip} controller to monitor, detect and correct radiation-induced errors.

If the processor needs to perform a partial reconfiguration in a specific region of the fabric, control must be handed back to the \gls{pcap}.

When using the \gls{semip} Controller, this action is not as simple as changing the mux~\cite{Ayer_XAPP517_2011,Xilinx_ICAP_PCAP_2016,Xilinx_XAPP517} configuration. The following actions should take place \cite{ZanoneSaotome2023}:
\begin{itemize}
\label{itemized-actions-for-dpr&sem}
    \item Set \gls{semip} in \texttt{IDLE} mode.
    \item Send an \texttt{SYNC} command to stop the \gls{semip} frame’s error scanning.
    \item Select the \gls{pcap} port and perform a \gls{dpr}.
    \item After \gls{dpr} is complete, transfer control of \gls{cram} back to \gls{semip}, through \gls{icap}.
    \item Perform a soft reset on \gls{semip}.
    \item Set \gls{semip} to \texttt{OBSERVATION} mode.
\end{itemize}

Figure~\ref{fig:fpga_mux} shows the interfaces that were developed to decouple \gls{semip} from \gls{icap}, switching the control to \gls{pcap} to perform the partial reconfiguration. The items highlighted in yellow allow steps 2 and 4 of the procedure to be correctly executed.

To stop \gls{sem} \gls{ip} scanning, the controller should be configured in IDLE mode, and a SYNC word command should be sent through the mux to \gls{icap}. This is accomplished using the output of the \texttt{\gls{icap} Sync controller} block that sends the value \texttt{0x5599AA66}.

When \gls{dpr} is finished, \gls{pcap} can switch the control back to the \gls{sem} controller. This is accomplished by commanding the \texttt{value of icap\_sel} and setting the mux to connect \gls{sem} \gls{ip} to \gls{icap}.

After a partial reconfiguration is performed, before \gls{sem} \gls{ip} returns to the observation mode, it is necessary to perform a soft reset in the controller, recalculating the FRAME \gls{ecc} of \gls{cram}. If \gls{sem} \gls{ip} is commanded back to observation mode without soft reset, the controller will detect reconfiguration as \glspl{seu} and will try to correct them.

If \gls{sem} \gls{ip} is not changed to IDLE mode prior to \gls{dpr}, it will continue in observation mode; then, during partial reconfiguration, the changes in \gls{cram} will be interpreted as \gls{seu}s. The \gls{sem} \gls{ip} will try to correct those bit flips, potentially entering a loop of error correction and reconfiguration, resulting in a failed reprogramming of the area.

It is important that all \gls{pcap} or \gls{icap} operations are completed before switching control between them. Figure~\ref{fig:fpga_mux} also shows that JTAG has precedence over both ports, so care should be taken when using JTAG together with \gls{pcap} and \gls{icap} to avoid interference between the ports.

\section{Implementation of N-Modular Redundancy}
In this section, the integration of the NMR scheme is detailed. The voter architecture, module replication strategy, and resource allocation are discussed. Specific design trade-offs such as latency, area overhead, and power consumption are analyzed to justify the parameters chosen for $N>3$.

In this work, both \gls{dmr} and \gls{tmr} architectures were implemented and subjected to \acrlong{fi} experiments to assess their fault-masking behavior and validate the proposed evaluation framework. The fault injection process was used to introduce controlled upsets into the redundant modules, allowing analysis of how each redundancy scheme reacts to injected faults under similar test conditions.

\subsection{DMR}

Figure~\ref{fig:fir-dmr} illustrates the architecture proposed to evaluate the design \gls{dmr} in this study. The design consists of two \glspl{fir} filters and an output voter, implemented to assess the effects of \gls{fi} on \gls{cram} of \gls{fpga}.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap4/fir-dmr.png}
    \caption{Block diagram of the proposed duplicated (\acrshort{dmr}) \acrshort{fir} filter architecture.}
    \label{fig:fir-dmr}
\end{figure}

Figure~\ref{fig:dut_fir_bird_view} illustrates the design implemented in the \gls{dmr} architecture using the Vivado tool. The \gls{semip} is instantiated together with the wrapper that consists of both, the \gls{fir} filters and the \gls{ps}. 

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap4/dut_fir_bird_view.png}
    \caption{Block diagram representation for the Vivado implementation, showing the \acrshort{fir} filter implemented in the \textit{My Design} block and the \acrshort{sem} wrapper containing the scrubber, which integrates the \acrshort{semip} and the ARM processor.}
    \label{fig:dut_fir_bird_view}
\end{figure}

Figure~\ref{fig:setup-fir} show the block diagram with the interconnections of all modules to validate the \gls{dmr} design with two \glspl{fir}. The \gls{semip} is used for \gls{ms} and \gls{fi}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{Cap5//dut_fir/setup-fir.png}
    \caption{Block Diagram of the \acrshort{dmr} evaluation in fpga and the \acrshort{fi} campaign.}
    \label{fig:setup-fir}
\end{figure}

Figure~\ref{fig:detail_fir} illustrates the \gls{dmr} architecture in detail. The \gls{rom} contains the input data for the \gls{fir} modules, whose outputs are compared by the checker block. The comparison results are then transmitted via serial communication to the \gls{fi} computer for evaluation.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap4/detail_fir.png}
    \caption{Zoomed block diagram of the \acrshort{fir} implementation in Vivado, showing the \acrshort{dmr} architecture and the detection circuit used to verify output correctness between modules.}
    \label{fig:detail_fir}
\end{figure}

\subsection{TMR}

For the \gls{tmr} evaluation conducted in this study, the \gls{cgtmr} method with a single word voter was selected. As discussed in Section~\ref{sec:cap3}, the word voter was chosen because it provides better results when applied to buses and wide data words. In this case, most voters operate on 32-bit signals due to the use of the \gls{riscv} processor.

Figure~\ref{riscv-tmr-diagram}, illustrates the \gls{tmr} design architecture using PicoRV32I. The redundancy is applied in the module level, replicating the entire soft core processor.

Figure~\ref{vivado-tmr} illustrates the \gls{tmr}-protected PicoRV32I implementation in Vivado. It is possible to observe the triplicated \gls{riscv} cores, as well as the voters inserted into each processor output that interfaces with the memory. In this study, the memory was neither triplicated nor equipped with any form of \gls{ecc} protection.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{Cap4/riscv-tmr-diagram.png}
    \caption{Block diagram of the proposed triplicated (\acrshort{tmr}) PicoRV32I architecture, showing the three replicated processor cores and the majority voter responsible for fault masking at the output stage.}
    \label{riscv-tmr-diagram}
\end{figure}

\begin{landscape}
    \begin{figure}[H]
    \centering
    \includegraphics[width=1.5\textwidth]{Cap4/tmr-vivado.png}
    \caption{Block Diagram of the implementation in Vivado. In the blue square (left) the memory for the \acrshort{riscv} instructions (firmware), in the red square (center) the triplicated \acrshort{riscv} cores and in the black square (right) the word voters inserted in each output of the PicoRV32 RISC-V core.}\label{vivado-tmr}
\end{figure}\end{landscape}

The \gls{fgtmr} approach was not selected due to its high level of intrusiveness, which increases the complexity of the design and often results in increased use of area and degraded synchronization and timing between modules \cite{Wilson2025,Adria2023}.

As discussed in ~\textcite{Koers2024}, the attempt to vote signals from a larger number of outputs did not lead to an improvement in the results. Expanding the voting scheme to include more signals increases the utilization of the design area, which may nearly occupy the entire device and consequently increases the probability of a fault affecting a critical element compared to a smaller, more compact design. In contrast, the voter logic itself occupies only a small portion of the overall architecture, making it statistically less likely that a configuration bit associated with the voter will be affected by a fault.

\subsection{Synthesis control for redundancy}

It is essential, when designing systems based on modular redundancy, to carefully analyze the synthesis and implementation logs generated by the design tool---in this work, Vivado---to ensure that redundant modules are not optimized away.

Since modular redundancy typically employs multiple identical instances of a module operating in parallel and receiving identical input signals, as illustrated in Figure~\ref{riscv-tmr-diagram}, the synthesis tool can infer functional equivalence between them. Consequently, since these modules generate the same output, the tool might remove one or more instances during optimization.

In Vivado, one message that may indicate such an optimization is the following:

\begin{verbatim}
[Synth 8-223] decloning instance <name> to <name>
\end{verbatim}

This message indicates that the tool has merged or eliminated redundant module instances (``clones''), which may compromise the intended fault-tolerant behavior of the design.

As presented by \textcite{acmeTuto}, one possible solution to this issue is the inclusion of the attribute \texttt{dont\_touch} in the design. This attribute is recognized by the synthesis tool and propagated to the place-and-route stages, ensuring that the specified object is preserved and not subject to optimization \cite{AMD:KEEP_DONT_TOUCH}.

The following examples illustrate how to apply this attribute in different design description contexts:

\begin{itemize}
    \item \textbf{\gls{tcl} Script (Vivado Constraint):}
    \begin{verbatim}
    set_property DONT_TOUCH true [get_cells <module_name>]
    \end{verbatim}

    \item \textbf{Verilog:}
    \begin{verbatim}
    (* DONT_TOUCH = "true" *) module <module_name> (...);
    endmodule
    \end{verbatim}

    \item \textbf{\gls{vhdl}:}
    \begin{verbatim}
    attribute DONT_TOUCH : string;
    attribute DONT_TOUCH of <entity_name> : entity is "true";
    \end{verbatim}
\end{itemize}

Another configuration applied to both architectures was the disablement of \gls{dsp}48 blocks in \gls{fpga}. This ensured that the design was implemented exclusively using \glspl{lut}, which made the \gls{fi} process more consistent and easier to emulate.

\begin{itemize}
    \item \textbf{\gls{tcl} Script (Vivado Constraint):}
    \begin{verbatim}
    set_property USE_DSP48 no [get_cells <module_name>]
    \end{verbatim}
\end{itemize}

\section{Dynamic Partial Reconfiguration Flow}

The \gls{dpr} flow is supported by Vivado; however, it is not yet fully integrated into the GUI-based project workflow~\cite{vipin2018dpr}. Consequently, the designs was implemented using the Vivado \gls{tcl}-based command flow. To facilitate the reproduction of results and provide a baseline configuration for future studies employing this architecture, a set of scripts were developed to automatically generate a project with two \gls{pr} modules, executing the following steps:

\begin{itemize}
    \item Create the project and block design.
    \begin{itemize}
        \item The block design should contain the ARM processing system instance.
        \item The reconfigurable items should have only the interface definitions declared in this step.
    \end{itemize}
    \item Synthesize the design, generating all the \gls{dcp} for the static region and blocks of logic.
    \item Load the \gls{dcp} for the static region and one of the \gls{rp}.
    \item Define \gls{rp} properties.
    \item Run the \gls{drc}.
    \item Create and implement the first configuration.
    \begin{itemize}
        \item  It is important that all configurable resources (\glspl{lut}, \glspl{ff}, \glspl{bram}, \glspl{dsp}) needed by the design must be available in the space allocated for the partial area.
    \end{itemize}
    \item Create all other configurations.
    \item Verify all configurations using the \texttt{PR\_verify} command.
    \item Generate bitstreams.
\end{itemize}

The \gls{dpr} process is carried out through the ARM's \gls{pcap} interface. Initially, the full or partial bitstream is stored in the processor’s \gls{ddr} memory, after which a \gls{dma} transfer sends it to the configuration memory of the programmable logic (PL) via the \gls{pcap} port.

Figure~ref{vivado-pr-math} shows the implementation of the \gls{dpr} architecture presented in Figure~\ref{zynq-paper-arch}. It shows the \gls{pr} instance of the mathematical module, using the \gls{axi} bus.

\begin{landscape}
    \begin{figure}[ht]
    \centering
    \includegraphics[width=1.5\textwidth]{Cap4/pr_math_bd.png}
    \caption{Block diagram of the Vivado design implementation. The blue square (center) shows the \acrshort{dpr} region containing the reconfigurable mathematical function (multiplier or adder), the red square (left) identifies the \gls{pr} block designation, and the violet square (right) highlights the \acrshort{pr} decoupler responsible for isolating the \acrshort{axi} bus during reconfiguration.}\label{vivado-pr-math}
\end{figure}\end{landscape}

\section{Fault Injection Strategy}
\label{sec:fi-strategy}
This subsection describes how the faults were emulated in the \gls{fpga} to validate the robustness of the system. Both hardware-based and software-assisted fault injection approaches are explained, along with fault models (\gls{see} and \gls{mbu}) and their mapping to the \gls{fpga} fabric. The methodology ensures repeatability and coverage of critical failure modes.

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{Cap4/error_injection.png}
    \caption{Block diagram representation of the \acrlong{fi} campaign and setup.}
    \label{error-injection-diagram}
\end{figure}

As illustrated in Figure~\ref{error-injection-diagram}, the mitigation core employed in this study is based on the \gls{semip} and AMD/Xilinx primitives that allow read-back and correction of the \gls{fpga}'s \gls{cram}. Since the device includes a \gls{ps}, it is used both to configure the bitstream and to serve as the \gls{sw} platform for system control. The \gls{dpr} region is used to dynamically switch functionality within the \gls{pl}, in this case, between a multiplier and an adder module.

As explained in Section~\ref{sec:cap3}, the configuration memory is distributed throughout \gls{fpga}, defining the functionality of its internal resources, including \glspl{clb}, \glspl{bram}, \glspl{dsp}, and routing interconnections. This memory is organized into frames arranged in rows and columns corresponding to specific configurable resources, with multiple frames per column forming clock regions within the device. To perform \gls{fi}, it is necessary to identify and extract the frame addresses, along with the words and bits within those frames, that correspond to the \gls{dut} \cite{Garcia2020}.

For this purpose, Xilinx provides the \textit{Essential Bits} technology~\cite{Garcia2020,Yang2022_FaultInjectionUltrascale}, which generates, along with the bitstream, a mask file indicating whether each configuration bit is used in the design. This information is stored in the \texttt{.ebd} file. To enable the generation of the \gls{ebd} file, the following constraint must be added to the Vivado project:

\begin{itemize}
    \item \textbf{\gls{tcl} Script (Vivado Constraint):}
    \begin{verbatim}
set_property BITSTREAM.SEU.ESSENTIALBITS YES [current_design]
    \end{verbatim}
\end{itemize}

The mapping between the \gls{ebd} file and the configuration memory enables the identification of configuration bits that are essential for the implemented design. This mapping provides a practical foundation for correlating the logical elements defined during synthesis with their physical representation in the configuration frames \gls{fpga}, thereby allowing for precise targeting of the configuration bits during \gls{fi} experiments.

The \emph{\acrfull{ebc}} file contains the reference data of all \gls{cram} cells of the \gls{fpga}. It represents the actual content that the \gls{semip} controller would read during a \gls{seu} read back operation. It is important to emphasize that the \gls{ebc} file is not the FPGA programming bitstream, but a representation of the configuration data after implementation.

The \emph{\acrfull{ebd}} file acts as a mask for the EBC file, identifying which bits are considered \textit{essential} to the correct operation of the implemented design. Each bit with a value of ‘1’ in the \gls{ebd} file indicates that the corresponding bit in the \gls{ebc} file is essential or potentially critical to the functionality of the system.

In summary, essential bits can potentially cause an error in \gls{dut} when corrupted. To determine which essential bits are actually capable of producing a malfunction, fault injection experiments are performed. The subset of essential bits that, when flipped, result in erroneous behavior of the system are defined as \textit{critical bits}. This is illustrated in Figure~\ref{fig:xilinx-ebd-ebc}, with examples of each file and the number of essential bits.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap4/xilinx-ebd-ebc.png}
        \caption{Final implementation report from Xilinx, showing the number of critical bits identified in the design and details from the \acrshort{ebd} and \acrshort{ebc} files.}
    \label{fig:xilinx-ebd-ebc}
\end{figure}

Simulation-based \gls{fi} provides high controllability and low cost, as no physical device is required. However, it suffers from long simulation times, particularly for complex systems, and may fail to capture intricate faulty behaviors, especially when performed at high levels of abstraction. When the objective is to evaluate the effects of faults in the \gls{fpga} bitstream, the use of a real device becomes essential~\cite{NazarCarro_DFT_FastSingleFPGA, Antoni2003}. In this context, this research employs \gls{cram} \gls{fi} through \gls{semip} to test the effects of bit-flips directly in the \gls{cram} of \gls{fpga}.

This approach represents an intermediate solution for exposing the \gls{fpga} to radiation effects, as it can be performed in standard laboratory environments at a significantly lower cost than physical radiation-based \gls{fi} testing.

For this research, the deterministic fault injection method was chosen, as the main objective was to evaluate the mitigation techniques and analyze how bit flips affect the overall functionality of the design.

So the \gls{ebc} and \gls{ebd} files were used in conjunction to the method explained in \textcite{Aranda2019} to calculate the critical frames of the intended region for injection. To calculate these frames, the \gls{dut} is implemented in a specific area of \gls{fpga}, using the \emph{pblock} design constraint of the Vivado. Pblocks define physical regions during floorplanning, allowing related logic to be grouped and placed within a specific area of the device \cite{Xilinx_UG912_PBLOCK}.

Figure~\ref{fig:pblock-fir-filter} shows the \gls{dmr} \gls{fir} implementation, the first \gls{dut} used in the \gls{fi} campaign. In this figure, it can be seen that \gls{fir}1 is completely placed within the Pblock named MY\_DUT, which is colored in yellow in the X1Y1 region of Zynq \gls{fpga}.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap4/pblock-fir-filter.png}
    \caption{Implementation of the \gls{fir}1 \gls{dut} within a Pblock region of the Zynq \gls{fpga}, highlighted in yellow.}
    \label{fig:pblock-fir-filter}
\end{figure}

\section{Integration with Processing System (PS)}
The \gls{ps} is used solely to control the overall operation of the design. A selection menu was developed to allow interaction through the serial interface, allowing control of the system’s behavior, reconfiguration of the \gls{pr} region with a new bitstream, and monitoring of the device’s voltage rails.

Additionally, \gls{ps} communicates via the \gls{axi} bus with the math block implemented in the \gls{dpr} region of \gls{fpga}.

\section{Verification and Validation Methodology}
This section presents the methodology adopted to verify and validate the proposed fault-tolerant platform. The process aimed to ensure both the functional correctness of the developed architectures and the effectiveness of the mitigation strategies under controlled fault conditions. The verification workflow was divided into three complementary stages: functional simulation, emulation with synthetic stimuli, and validation on physical \glspl{fpga}.

\subsection{Functional Verification}

Functional verification was first carried out at the \gls{rtl} level using the simulation environment of the Vivado Design Suite. Behavioral testbenches were created for each module, including the \gls{fir} filters, \gls{tmr} PicoRV32I cores, and the scrubbing controller wrapper. The objective of this stage was to verify correct signal propagation, timing relationships, and overall functional equivalence between redundant instances before synthesis.

To automate and accelerate this process, Python scripts were used to generate stimuli and compare simulation outputs with reference data stored in \gls{rom} memories. Assertions were added in the simulation environment to detect mismatches between module outputs, ensuring that all logic behaved deterministically prior to hardware implementation.

\subsection{Emulation and Hardware-in-the-Loop Verification}

After successful behavioral verification, the system was synthesized and implemented on the PYNQ-Z2 development board for hardware-in-the-loop testing. This stage focused on validating correct communication between the \gls{ps} and the \gls{pl}, including proper configuration of the \gls{axi} interconnect, clock domains, and synchronization signals between the \gls{semip}, the reconfigurable regions, and the processing system.

During this phase, partial bitstreams were reloaded at runtime through the \gls{pcap} interface, verifying the operation of the \gls{pr} decoupler and confirming that the static logic remained operational throughout the reconfiguration. UART communication was continuously monitored to detect any interruptions or unexpected resets during reconfiguration events.  

The same procedure was repeated with the \gls{semip} actively scrubbing the device to confirm that switching between \acrshort{pcap} and \gls{icap} interfaces followed the synchronization sequence defined in Section~\ref{itemized-actions-for-dpr&sem}.

\subsection{Fault Injection Validation}

Once the architecture was functionally stable, validation under fault conditions was conducted using the deterministic \acrshort{fi} approach described in Section~\ref{sec:fi-strategy}. The \gls{semip} was configured in injection mode to emulate single-bit upsets (SEUs) and multi-bit upsets (MBUs) directly in the \gls{cram} of the \gls{fpga}.  

Each injected fault was automatically logged, including the frame address, bit offset, and injection timestamp. The system response was observed via UART to determine whether the error was masked, corrected, or resulted in a system failure. The injected faults were correlated with the essential bits identified in the \acrshort{ebd} file to classify them as either benign or critical.  

The mais metrics extracted from this campaign was Fault coverage, the ratio between detected or masked faults and total injected faults.

\subsection{Performance and Resource Monitoring}

Throughout all verification stages, Vivado reports and the \texttt{report\_utilization} command were used to track the consumption of \glspl{lut}, \glspl{ff}, \glspl{bram}, and \glspl{dsp}. The goal was to quantify the area overhead introduced by \acrshort{nmr} and \acrshort{dpr} features.  

In addition, on-chip sensors accessible through the \acrshort{ps} were used to monitor supply voltages and temperature variations during reconfiguration and fault-injection cycles, ensuring thermal and electrical stability of the device.

\subsection{Summary of Validation Strategy}

The combined use of simulation, emulation, and in-hardware fault injection enabled comprehensive validation of the proposed platform. Functional verification ensured design correctness, emulation confirmed system-level integration, and real fault injection provided empirical evidence of fault-tolerance efficiency.  

\section{Summary}
This chapter presented the methodology adopted for the design, implementation, and validation of the proposed fault-tolerant platform. It began by introducing the hardware and software environments used throughout development, highlighting the Pynq-Z2 board based on the Zynq 7000 \gls{soc} and the Vivado~2018.3 toolchain complemented by Python automation scripts and the \gls{riscv} GNU toolchain.

The reference design architecture was defined to integrate three key mechanisms: the \gls{semip} controller for \gls{ms}, \gls{dpr} for runtime reconfiguration of specific hardware regions, and \gls{fi} for controlled evaluation of reliability. The interaction between the \gls{semip} and the \gls{dpr} flows was carefully managed through \gls{pcap}/\gls{icap} switching, ensuring proper coordination between scrubbing operations and partial reconfiguration events.

Next, the implementation of \acrshort{nmr} was detailed, focusing on \gls{dmr} and \gls{tmr} configurations applied to \acrshort{fir} filters and \gls{riscv} processor cores. Special attention was given to synthesis constraints and placement strategies to prevent optimization of redundant modules and guarantee physical separation of replicas.

The chapter also described the \gls{tcl}-based \gls{dpr} automation flow, designed to streamline the generation of partial bitstreams and their verification. The \gls{fi} methodology was then explained, including the use of Xilinx’s \textit{Essential Bits} technology (\gls{ebd}/\gls{ebc} files) to target configuration frames within the \gls{dut}. The resulting deterministic fault-injection campaign enabled systematic evaluation of the system’s response to configuration upsets.

Finally, the integration of the programmable logic with the \gls{ps} was addressed, showing how the \gls{ps} ARM cores coordinate system operation, reconfiguration control, and serial communication for monitoring. The chapter concluded with the definition of the verification and validation strategy, establishing the experimental basis for the performance and reliability results discussed in the next chapter.
