%\section{Development Methodology}
\label{sec:cap4}

This chapter details the methodology adopted to design, implement and validate the proposed fault-tolerance approach. Describes the workflow, design tools, experimental setup, and evaluation strategies applied throughout development.

For easier development and debugging, the entire design was broken down into modules and developed independently before integrating it all together into one final architecture. For this, each mitigation was developed and tested independently and, ultimately, all mitigations were implemented in a final solution with a \gls{tmr} \gls{riscv} 32I.

\section{FPGA Platform and Toolchain}
\label{sec:cap4-material}
This section presents the selected \gls{fpga} device, development board, and software toolchain. The hardware platform was chosen considering resource availability, \gls{dpr} capabilities, and compatibility with on-chip fault injection tools. The toolchain description includes synthesis tools, placement-and-routing strategies, and configuration methods.

\begin{table}[ht]
\caption{List of \acrlong{sw} development tools employed in this work}
\label{tab:sw-tools}
\centering
\begin{adjustbox}{max width=\paperwidth}
\begin{tabular}{c p{12cm}}
\hline
\textbf{Tool} & \textbf{Description} \\
\hline
\href{https://www.xilinx.com/products/design-tools/vivado.html}{Vivado 2018.3} &
Xilinx \gls{fpga} design suite used for \gls{hdl} synthesis, implementation, and bitstream generation. Provides Tcl scripting support for automation. \\

\href{https://www.python.org/}{Python} &
High-level programming language for automation, scripting, and testbench development. Widely used to coordinate \gls{fpga} workflows and fault injection experiments. \\

\href{https://github.com/riscv-collab/riscv-gnu-toolchain}{RISC-V Toolchain} &
Open-source GNU toolchain supporting the RISC-V ISA, enabling firmware compilation and debugging for soft-core processors like PicoRV32 \cite{PICORV32I}. \\

\href{https://github.com/YosysHQ/picorv32/}{PicoRV32} &
Compact and configurable RISC-V soft processor core optimized for \gls{fpga}, often used for embedded control, monitoring, and fault injection control logic. \\
\hline
\end{tabular}
\end{adjustbox}
\end{table}

Table~\ref{tab:sw-tools} lists the \gls{sw} resources and the \gls{riscv} \textit{soft-core} utilized in this work. The development environment was based on the \href{https://releases.ubuntu.com/18.04/}{Linux Ubuntu 18.04} operating system, which provided stability and compatibility with the required toolchain.

Table~\ref{tab:hw-tools} presents the \gls{hw} development platforms used in this research.

\begin{table}[ht]
\caption{List of \acrlong{hw} development kits employed in this work}
\label{tab:hw-tools}
\centering
\begin{adjustbox}{max width=\paperwidth}
\begin{tabular}{c p{12cm}}
\hline
\textbf{Tool} & \textbf{Description} \\
\hline
\href{https://www.amd.com/en/corporate/university-program/aup-boards/pynq-z2.html}{Pynq Z2} &
The PYNQ-Z2 is a development board designed for experimenting with FPGAs and embedded systems in an accessible way. It is based on the Xilinx Zynq-7000 SoC (System on Chip). Specifically the Zynq XC7Z020, the same device used in the \href{https://www.amd.com/en/search/partner/embedded-partner-solutions.html#/6821}{Zedboard} development kit. \\

\href{https://ftdichip.com/products/ft2232hq/}{FT2232} &
The FT2232 is a USB-to-multi-purpose communication interface IC developed by FTDI (Future Technology Devices International).
It is widely used for bridging USB connections to various serial and parallel protocols, making it especially popular in \gls{fpga} development boards, embedded systems, and debugging tools. \\
\hline
\end{tabular}
\end{adjustbox}
\end{table}

\section{Reference Design Architecture}
\label{sec:ref-design-arch}
To acquire the necessary knowledge to implement the final solution, the first step consisted of developing an initial architecture containing all the required components.

The requirements for this architecture were established on the basis of the following key assumptions:

\begin{itemize}
    \item \textbf{Configuration Memory Scrubbing (CRAM Scrubbing):}  
    Periodic correction of configuration memory upsets to maintain system integrity and prevent fault accumulation.

    \item \textbf{Dynamic Partial Reconfiguration (DPR):}  
    Ability to reconfigure specific regions of the \gls{fpga} at runtime without interrupting the operation of the static logic.

    \item \textbf{Fault Injection Capability:}  
    Implementation of controlled fault injection mechanisms to evaluate the system’s fault tolerance and recovery strategies.
\end{itemize}

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{Cap4/architecture.png}
    \caption{Block diagram representation of the proposed fault-tolerant platform, highlighting the integration between the \acrshort{soc} processor, reconfigurable hardware modules, and the supporting infrastructure for \acrshort{fi}, \acrshort{dpr}, and scrubbing operations.}
    \label{zynq-paper-arch}
\end{figure}

As illustrated  in Figure~\ref{zynq-paper-arch}, the core of the architecture is the Xilinx Zynq-7000, a \gls{soc} integrating a dual-core ARM A9 processor with an \gls{fpga} fabric on the same die.

\subsection{Soft Error Mitigation}
To protect the \gls{sram}-based \gls{fpga}, Xilinx’s \gls{semip}, \cite{amd2023sem} is being used in this platform. The controller can be accessed from a serial console and provides the status of the configuration memory, injection of errors and operational status.

It is possible to communicate with the controller using the AXI Bus of the processor, but for this study an external UART was attached to the design, providing an easy way to use an external PC with a script to inject error and check how the platform behaves.

The \gls{semip} was selected as the scrubbing methodology because it is natively available on the 7-series device used in this work and supports \gls{fi} within the same \gls{ip}. This approach is considered an internal scrubbing technique, as it leverages the embedded \gls{ecc} present in each configuration frame of the \gls{fpga}, thereby eliminating the need for an external memory to store the golden bitstream.

\subsection{Dynamic Partial Reconfiguration}
Dynamic partial reconfiguration is performed through the ARM´s \gls{pcap} port.
The full or partial bitstream can be loaded from an external memory, for example, the ARM processor's \gls{ddr} memory or SD-Card. With the bitstream stored in the \gls{ddr}, the file is transferred to the PL configuration memory using the \gls{pcap} port using \gls{dma}. This setup frees the processor, and the bitstream is directly loaded into the \gls{fpga} \gls{cram} without processing interruption.

The main idea of the \gls{dpr} region, denoted by the \emph{"HW Accel."} in Figure~\ref{zynq-paper-arch}, is to perform any kind of hardware acceleration needed by the application, being able to reprogram this area accordingly to the need circuit or function needed at that time, giving the system some sort of hardware redundancy in time.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\textwidth]{Cap4/dpr-partial-bit.png}
    \caption{Representation of “partial” bitstreams used in \acrshort{dpr}, which modify only a specific region of the \acrshort{fpga} fabric while preserving the operation of static regions.}
    \label{dpr-partial-diagram}
\end{figure}

As illustrated in Figure~\ref{dpr-partial-diagram}, it is possible to create any combination of partial bitstreams that can have different functions, for example a multiplier, an adder, a filter or any other needed function. Then, this can be dynamically programmed in this area, changing the behavior of the system without affecting the other function around it.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\textwidth]{Cap4/dpr-full-bit.png}
    \caption{Representation of the “full” bitstream, which contains the complete configuration data required to program all regions of the \acrshort{fpga}, including static and reconfigurable areas.}
    \label{dpr-full-diagram}
\end{figure}

As illustrated in Figure~\ref{dpr-full-diagram}, the full bitstream reconfigures the entire \gls{fpga} \gls{cram}, so the entire circuit needs to be shut off and will only return to function when the complete reprogram is complete.

The size of the bitstreams, illustrated by the squares in Figures ~\ref{dpr-partial-diagram} and~\ref{dpr-full-diagram}, gives the exact notion of the time needed to reprogram \gls{fpga} \gls{cram}. As the partial bitstream only reprograms a small portion of the device, the full bitstream will reprogram the entire device. So, this translates into the difference in the size of files and the time needed for reconfiguration. 

\subsection{Integration of \glsentrytext{dpr} and \glsentrytext{sem} in the same project}

As defined in \textcite{Xilinx_DS190},the processor sub-system, present in  Zynq device family, has control, at power-up, of all configurations to \gls{pl}, using the \gls{pcap} port. The system is designed this way mainly because of the following facts:
\begin{itemize}
    \item Improvement in the overall security of the design, as the Arm's TrustZone shall take control of the configuration port and, using its set of registers, allow only the non-secure fabric \gls{icap} port to configure the device.
    \item Allows the \gls{fpga} to be configured at boot time, through Arm's \gls{fsbl}.
\end{itemize}

The selection of the interface under control of the \gls{fpga} configuration is made using a 2:1 mux, controlled by the \texttt{PCAP\_PR} register, as illustrated  in Figure~\ref{fig:fpga_mux}.

\begin{figure}[ht!]
    \centering
    \includegraphics[width=1\textwidth]{Cap4/cram.png}
    \caption{Block representation illustrating the data flow and access priorities among the \acrshort{fpga} configuration interfaces, showing how \acrshort{pcap}, \acrshort{icap}, \acrshort{jtag}, and \acrshort{semip} ports interact with the device’s \acrshort{cram}.}
    \label{fig:fpga_mux}
\end{figure}

After initial configuration (or at any time), the processor may set the control bit to switch the configuration interface to be accessed internally to the \gls{fpga} fabric; then \gls{icap} becomes active.

As illustrated  in Figure~\ref{fig:fpga_mux}, the \gls{semip} controller uses the port \gls{icap} to perform the scrubbing \gls{cram}. So, after the initial configuration, the processor should release \gls{pcap} and pass the control to \gls{icap}, allowing the \gls{semip} controller to monitor, detect, and correct radiation-induced errors.

If the processor needs to perform a partial reconfiguration in a specific region of the fabric, control must be handed back to the \gls{pcap}.

When using the \gls{semip} Controller, this action is not as simple as changing the mux~\cite{Ayer_XAPP517_2011,Xilinx_ICAP_PCAP_2016,Xilinx_XAPP517} configuration. The following actions should take place \cite{ZanoneSaotome2023}:
\begin{itemize}
\label{itemized-actions-for-dpr&sem}
    \item Set \gls{semip} in \texttt{IDLE} mode.
    \item Send an \texttt{SYNC} command to stop the \gls{semip} frame’s error scanning.
    \item Select the \gls{pcap} port and perform a \gls{dpr}.
    \item After \gls{dpr} is complete, transfer control of \gls{cram} back to \gls{semip}, through \gls{icap}.
    \item Perform a soft reset on \gls{semip}.
    \item Set \gls{semip} to \texttt{OBSERVATION} mode.
\end{itemize}

Figure~\ref{fig:fpga_mux} shows the interfaces that were developed to decouple \gls{semip} from \gls{icap}, switching the control to \gls{pcap} to perform the partial reconfiguration. The items highlighted in yellow allow steps 2 and 4 of the procedure to be correctly executed.

To stop \gls{sem} \gls{ip} scanning, the controller should be configured in IDLE mode, and a SYNC word command should be sent through the mux to \gls{icap}. This is accomplished using the output of the \texttt{\gls{icap} Sync controller} block that sends the value \texttt{0x5599AA66}.

When \gls{dpr} is finished, \gls{pcap} can switch the control back to the \gls{sem} controller. This is accomplished by commanding the \texttt{value of icap\_sel} and setting the mux to connect \gls{sem} \gls{ip} to \gls{icap}.

After a partial reconfiguration is performed, before \gls{sem} \gls{ip} returns to the observation mode, it is necessary to perform a soft reset in the controller, recalculating the FRAME \gls{ecc} of \gls{cram}. If \gls{sem} \gls{ip} is commanded back to observation mode without soft reset, the controller will detect reconfiguration as \glspl{seu} and will try to correct them.

If \gls{sem} \gls{ip} is not changed to IDLE mode prior to \gls{dpr}, it will continue in observation mode; then, during partial reconfiguration, the changes in \gls{cram} will be interpreted as \gls{seu}s. The \gls{sem} \gls{ip} will try to correct those bit flips, potentially entering a loop of error correction and reconfiguration, resulting in a failed reprogramming of the area.

It is important that all \gls{pcap} or \gls{icap} operations are completed before switching control between them. Figure~\ref{fig:fpga_mux} also shows that JTAG has precedence over both ports, so care should be taken when using JTAG together with \gls{pcap} and \gls{icap} to avoid interference between the ports.

\section{Implementation of N-Modular Redundancy}
In this section, the integration of the NMR scheme is detailed. The voter architecture, module replication strategy, and resource allocation are discussed. Specific design trade-offs such as latency, area overhead, and power consumption are analyzed to justify the parameters chosen for $N>3$.

In this work, both \gls{dmr} and \gls{tmr} architectures were implemented and subjected to \acrlong{fi} experiments to assess their fault-masking behavior and validate the proposed evaluation framework. The fault injection process was used to introduce controlled upsets into the redundant modules, allowing analysis of how each redundancy scheme reacts to injected faults under similar test conditions.

\subsection{DMR}

Figure~\ref{fig:fir-dmr} illustrates the architecture proposed to evaluate the design \gls{dmr} in this study. The design consists of two \glspl{fir} filters and an output voter, implemented to assess the effects of \gls{fi} on \gls{cram} of \gls{fpga}.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap4/fir-dmr.png}
    \caption{Block diagram of the proposed duplicated (\acrshort{dmr}) \acrshort{fir} filter architecture.}
    \label{fig:fir-dmr}
\end{figure}

Figure~\ref{fig:dut_fir_bird_view} illustrates the design implemented in the \gls{dmr} architecture using the Vivado tool. The \gls{semip} is instantiated together with the wrapper that consists of both, the \gls{fir} filters and the \gls{ps}. 

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap4/dut_fir_bird_view.png}
    \caption{Block diagram representation for the Vivado implementation, showing the \acrshort{fir} filter implemented in the \textit{My Design} block and the \acrshort{sem} wrapper containing the scrubber, which integrates the \acrshort{semip} and the ARM processor.}
    \label{fig:dut_fir_bird_view}
\end{figure}

Figure~\ref{fig:detail_fir} illustrates the \gls{dmr} architecture in detail. The \gls{rom} contains the input data for the \gls{fir} modules, whose outputs are compared by the checker block. The comparison results are then transmitted via serial communication to the \gls{fi} computer for evaluation.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap4/detail_fir.png}
    \caption{Zoomed block diagram of the \acrshort{fir} implementation in Vivado, showing the \acrshort{dmr} architecture and the detection circuit used to verify output correctness between modules.}
    \label{fig:detail_fir}
\end{figure}

\subsection{TMR}

For the \gls{tmr} evaluation conducted in this study, the \gls{cgtmr} method with a single word voter was selected. As discussed in Section~\ref{sec:cap3}, the word voter was chosen because it provides better results when applied to buses and wide data words. In this case, most voters operate on 32-bit signals due to the use of the \gls{riscv} processor.

Figure~\ref{riscv-tmr-diagram}, illustrates the \gls{tmr} design architecture using PicoRV32I. The redundancy is applied in the module level, replicating the entire soft core processor.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{Cap4/riscv-tmr-diagram.png}
    \caption{Block diagram of the proposed triplicated (\acrshort{tmr}) PicoRV32I architecture, showing the three replicated processor cores and the majority voter responsible for fault masking at the output stage.}
    \label{riscv-tmr-diagram}
\end{figure}

Figure~\ref{vivado-tmr} illustrates the \gls{tmr}-protected PicoRV32I implementation in Vivado. It is possible to observe the triplicated \gls{riscv} cores, as well as the voters inserted into each processor output that interfaces with the memory. In this study, the memory was neither triplicated nor equipped with any form of \gls{ecc} protection.

\begin{landscape}
    \begin{figure}[H]
    \centering
    \includegraphics[width=1.5\textwidth]{Cap4/tmr-vivado.png}
    \caption{Block Diagram of the implementation in Vivado. In the blue square (left) the memory for the \acrshort{riscv} instructions (firmware), in the red square (center) the triplicated \acrshort{riscv} cores and in the black square (right) the word voters inserted in each output of the PicoRV32 RISC-V core.}\label{vivado-tmr}
\end{figure}\end{landscape}

The \gls{fgtmr} approach was not selected due to its high level of intrusiveness, which increases the complexity of the design and often results in increased use of area and degraded synchronization and timing between modules \cite{Wilson2025,Adria2023}.

\subsection{Synthesis control for redundancy}

It is essential, when designing systems based on modular redundancy, to carefully analyze the synthesis and implementation logs generated by the design tool---in this work, Vivado---to ensure that redundant modules are not optimized away.

Since modular redundancy typically employs multiple identical instances of a module operating in parallel and receiving identical input signals, as illustrated in Figure~\ref{riscv-tmr-diagram}, the synthesis tool can infer functional equivalence between them. Consequently, since these modules generate the same output, the tool might remove one or more instances during optimization.

In Vivado, one message that may indicate such an optimization is the following:

\begin{verbatim}
[Synth 8-223] decloning instance <name> to <name>
\end{verbatim}

This message indicates that the tool has merged or eliminated redundant module instances (``clones''), which may compromise the intended fault-tolerant behavior of the design.

As presented by \textcite{acmeTuto}, one possible solution to this issue is the inclusion of the attribute \texttt{dont\_touch} in the design. This attribute is recognized by the synthesis tool and propagated to the place-and-route stages, ensuring that the specified object is preserved and not subject to optimization \cite{AMD:KEEP_DONT_TOUCH}.

The following examples illustrate how to apply this attribute in different design description contexts:

\begin{itemize}
    \item \textbf{\gls{tcl} Script (Vivado Constraint):}
    \begin{verbatim}
    set_property DONT_TOUCH true [get_cells <module_name>]
    \end{verbatim}

    \item \textbf{Verilog:}
    \begin{verbatim}
    (* DONT_TOUCH = "true" *) module <module_name> (...);
    endmodule
    \end{verbatim}

    \item \textbf{\gls{vhdl}:}
    \begin{verbatim}
    attribute DONT_TOUCH : string;
    attribute DONT_TOUCH of <entity_name> : entity is "true";
    \end{verbatim}
\end{itemize}

Another configuration applied to both architectures was the disablement of \gls{dsp}48 blocks in \gls{fpga}. This ensured that the design was implemented exclusively using \glspl{lut}, which made the \gls{fi} process more consistent and easier to emulate.

\begin{itemize}
    \item \textbf{\gls{tcl} Script (Vivado Constraint):}
    \begin{verbatim}
    set_property USE_DSP48 no [get_cells <module_name>]
    \end{verbatim}
\end{itemize}

\section{Dynamic Partial Reconfiguration Flow}

The \gls{dpr} flow is supported by Vivado; however, it is not yet fully integrated into the GUI-based project workflow~\cite{vipin2018dpr}.
Consequently, the designs are typically implemented using the Vivado \gls{tcl}-based command flow, or through a combination of \gls{tcl} commands and the graphical interface.
To facilitate the reproduction of results and provide a baseline configuration for future studies employing this architecture, a set of scripts were developed to automatically generate a project with two modules \gls{pr}, executing the following steps:

\begin{itemize}
    \item Create the project and block design.
    \begin{itemize}
        \item The block design should contain the ARM processing system instance.
        \item The reconfigurable items should have only the interface definitions declared in this step.
    \end{itemize}
    \item Synthesize the design, generating all the \gls{dcp} for the static region and blocks of logic.
    \item Load the \gls{dcp} for the static region and one of the \gls{rp}.
    \item Define \gls{rp} properties.
    \item Run the \gls{drc}.
    \item Create and implement the first configuration.
    \begin{itemize}
        \item  It is important that all configurable resources (\glspl{lut}, \glspl{ff}, \glspl{bram}, \glspl{dsp}) needed by the design must be available in the space allocated for the partial area.
    \end{itemize}
    \item Create all other configurations.
    \item Verify all configurations using the \texttt{PR\_verify} command.
    \item Generate bitstreams.
\end{itemize}

The \gls{dpr} process is carried out through the ARM's \gls{pcap} interface. Initially, the full or partial bitstream is stored in the processor’s \gls{ddr} memory, after which a \gls{dma} transfer sends it to the configuration memory of the programmable logic (PL) via the \gls{pcap} port.

\begin{landscape}
    \begin{figure}[ht]
    \centering
    \includegraphics[width=1.5\textwidth]{Cap4/pr_math_bd.png}
    \caption{Block diagram of the Vivado design implementation. The blue square (center) shows the \acrshort{dpr} region containing the reconfigurable mathematical function (multiplier or adder), the red square (left) identifies the \gls{pr} block designation, and the violet square (right) highlights the \acrshort{pr} decoupler responsible for isolating the \acrshort{axi} bus during reconfiguration.}\label{vivado-pr-math}
\end{figure}\end{landscape}

\section{Fault Injection Strategy}
\label{sec:fi-strategy}
This subsection describes how the faults were emulated in the \gls{fpga} to validate the robustness of the system. Both hardware-based and software-assisted fault injection approaches are explained, along with fault models (single-event upsets, multiple-bit upsets) and their mapping to the \gls{fpga} fabric. The methodology ensures repeatability and coverage of critical failure modes.

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{Cap4/error_injection.png}
    \caption{Block diagram representation of the \acrlong{fi} campaign and setup.}
    \label{error-injection-diagram}
\end{figure}

As illustrated in Figure~\ref{error-injection-diagram}, the mitigation core employed in this study is based on the \gls{semip} and AMD/Xilinx primitives that allow read-back and correction of the \gls{fpga}'s \gls{cram}. Since the device includes a \gls{ps}, it is used both to configure the bitstream and to serve as the \gls{sw} platform for system control. The \gls{dpr} region is used to dynamically switch functionality within the \gls{pl}, in this case, between a multiplier and an adder module.

As explained in Section~\ref{sec:cap3}, the configuration memory is distributed throughout \gls{fpga}, defining the functionality of its internal resources, including \glspl{clb}, \glspl{bram}, \glspl{dsp}, and routing interconnections. This memory is organized into frames arranged in rows and columns corresponding to specific configurable resources, with multiple frames per column forming clock regions within the device. To perform \gls{fi}, it is necessary to identify and extract the frame addresses, along with the words and bits within those frames, that correspond to the \gls{dut} \cite{Garcia2020}.

For this purpose, Xilinx provides the \textit{Essential Bits} technology~\cite{Garcia2020,Yang2022_FaultInjectionUltrascale}, which generates, along with the bitstream, a mask file indicating whether each configuration bit is used in the design. This information is stored in the \texttt{.ebd} file. To enable the generation of the \gls{ebd} file, the following constraint must be added to the Vivado project:

\begin{itemize}
    \item \textbf{\gls{tcl} Script (Vivado Constraint):}
    \begin{verbatim}
set_property BITSTREAM.SEU.ESSENTIALBITS YES [current_design]
    \end{verbatim}
\end{itemize}

The mapping between the \gls{ebd} file and the configuration memory enables the identification of configuration bits that are essential for the implemented design. This mapping provides a practical foundation for correlating the logical elements defined during synthesis with their physical representation in the configuration frames \gls{fpga}, thereby allowing for precise targeting of the configuration bits during \gls{fi} experiments.

The \emph{\acrfull{ebc}} file contains the reference data of all \gls{cram} cells of the \gls{fpga}. It represents the actual content that the \gls{semip} controller would read during a \gls{seu} read back operation. It is important to emphasize that the \gls{ebc} file is not the FPGA programming bitstream, but a representation of the configuration data after implementation.

The \emph{\acrfull{ebd}} file acts as a mask for the EBC file, identifying which bits are considered \textit{essential} to the correct operation of the implemented design. Each bit with a value of ‘1’ in the \gls{ebd} file indicates that the corresponding bit in the \gls{ebc} file is essential or potentially critical to the functionality of the system.

In summary, essential bits can potentially cause an error in \gls{dut} when corrupted. To determine which essential bits are actually capable of producing a malfunction, fault injection experiments are performed. The subset of essential bits that, when flipped, result in erroneous behavior of the system are defined as \textit{critical bits}. This is illustrated in Figure~\ref{fig:xilinx-ebd-ebc}, with examples of each file and the number of essential bits.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Cap4/xilinx-ebd-ebc.png}
        \caption{Final implementation report from Xilinx, showing the number of critical bits identified in the design and details from the \acrshort{ebd} and \acrshort{ebc} files.}
    \label{fig:xilinx-ebd-ebc}
\end{figure}

Simulation-based \gls{fi} provides high controllability and low cost, as no physical device is required. However, it suffers from long simulation times, particularly for complex systems, and may fail to capture intricate faulty behaviors, especially when performed at high levels of abstraction. When the objective is to evaluate the effects of faults in the \gls{fpga} bitstream, the use of a real device becomes essential~\cite{NazarCarro_DFT_FastSingleFPGA, Antoni2003}. In this context, this research employs \gls{cram} \gls{fi} through \gls{semip} to test the effects of bit-flips directly in the \gls{cram} of \gls{fpga}.

\section{Integration with Processing System (PS)}
This section discusses how the ARM processing system in the \gls{soc} was used to monitor and control the fault-tolerant logic. Mitigation strategies were partially moved to the PS side to balance the workload and reduce logic overhead in the programmable fabric.

\section{Verification and Validation Methodology}
The testing strategy is presented to demonstrate how the design was verified at the simulation level, the emulation level, and on physical \gls{fpga} hardware. Metrics such as fault coverage, error latency, and resource usage were systematically measured to evaluate the effectiveness of the proposed solution.

\section{Summary}
This section summarizes the methodology chapter, highlighting the major design decisions and how they lay the groundwork for the results presented in the next chapter.

These added capabilities make the platform suitable for deployment in harsh environments, particularly for non-critical instrumentation and communication systems, as \gls{sram}-based \glspl{fpga} provide a cost- and area-efficient solution \cite{Brosser2014}.
